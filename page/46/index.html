<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">276</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">39</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/18/System-Design/9p/2019-04-18-MapReuce/">System-Design/9p/2019-04-18-MapReuce</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><h1 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map Reduce"></a>Map Reduce</h1><blockquote>
<p>Map<br> • 机器1，2 只负责把文章拆分为一个一个的单词</p>
<p>Reduce<br> • 机器3，4各负责一部分word的合并</p>
</blockquote>
<p>95%是在使用；　5%是在設計Map Reduce</p>
<p>只要大數據就該還是來了解</p>
<h2 id="統計單詞詞頻"><a href="#統計單詞詞頻" class="headerlink" title="統計單詞詞頻"></a>統計單詞詞頻</h2><ol>
<li>for + hash</li>
</ol>
<blockquote>
<h5 id="多选题-使用-For-循环统计单词个数有什么问题？"><a href="#多选题-使用-For-循环统计单词个数有什么问题？" class="headerlink" title="[多选题]使用 For 循环统计单词个数有什么问题？"></a>[多选题]使用 For 循环统计单词个数有什么问题？</h5><p>A.执行速度慢，单台机器要遍历所有单词50.47% 选择</p>
<p>B.耗费空间大，所有单词都要存储在 Hash 里进行计数统计47.48% 选择</p>
<p>C.编程复杂，代码实现难度高2.05% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是AB</p>
<p><strong>正确答案:</strong> AB</p>
</blockquote>
<ol start="2">
<li>多台機器平行統計，該怎麼切？</li>
</ol>
<blockquote>
<h5 id="单选题-按照内容存储顺序拆分统计，然后合并在一起的算法问题在哪儿？"><a href="#单选题-按照内容存储顺序拆分统计，然后合并在一起的算法问题在哪儿？" class="headerlink" title="[单选题]按照内容存储顺序拆分统计，然后合并在一起的算法问题在哪儿？"></a>[单选题]按照内容存储顺序拆分统计，然后合并在一起的算法问题在哪儿？</h5><p>A.无法做到均匀拆分26.18% 选择</p>
<p>B.机器的并行效率不高4.71% 选择</p>
<p>C.合并的时候太慢，会成为瓶颈69.11% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是C</p>
<p><strong>正确答案:</strong> C</p>
</blockquote>
<h3 id="合併的時候是Bottle-Neck"><a href="#合併的時候是Bottle-Neck" class="headerlink" title="合併的時候是Bottle Neck!"></a>合併的時候是Bottle Neck!</h3><p>是不是也可以平行？以什麼為標準來劃分？機器or Key?</p>
<blockquote>
<h5 id="单选题-合并的时候以什么作为划分依据？"><a href="#单选题-合并的时候以什么作为划分依据？" class="headerlink" title="[单选题]合并的时候以什么作为划分依据？"></a>[单选题]合并的时候以什么作为划分依据？</h5><p>A.机器25.45% 选择</p>
<p>B.Key74.55% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong> B</p>
<p><strong>解析:</strong> </p>
<p>以Key作为划分，设计简单，没有层次依赖性</p>
</blockquote>
<p>用機器的話會有層次、依賴性問題而拖慢整體速度。</p>
<h1 id="Map-Reduce-框架流程"><a href="#Map-Reduce-框架流程" class="headerlink" title="Map Reduce 框架流程"></a>Map Reduce 框架流程</h1><p>Map Reduce是一個分布式系統，整個都是由Master來控制的。</p>
<p>map的時候並沒有做合併aggregation的操作。</p>
<blockquote>
<h5 id="单选题-Word-Count-为什么没有在-Map-的时候做聚合（Aggregation）？"><a href="#单选题-Word-Count-为什么没有在-Map-的时候做聚合（Aggregation）？" class="headerlink" title="[单选题]Word Count 为什么没有在 Map 的时候做聚合（Aggregation）？"></a>[单选题]Word Count 为什么没有在 Map 的时候做聚合（Aggregation）？</h5><p>A.因为会使得编程复杂度提高15.39% 选择</p>
<p>B.因为聚合所需时间复杂度较高31.53% 选择</p>
<p>C.因为 Map Reduce 的框架会帮你实现41.83% 选择</p>
<p>D.因为 Map 的机器内存可能不够11.25% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是D</p>
<p><strong>正确答案:</strong> D</p>
</blockquote>
<p>不能在任何一個機器中開這個一樣哈希map。這裡不開的話，那麼整個系統都可以不開的。</p>
<h1 id="MR-的使用"><a href="#MR-的使用" class="headerlink" title="MR 的使用"></a>MR 的使用</h1><blockquote>
<p><strong>[LintCode 编程题]**</strong>[LintCode] Word Count (Map Reduce)**</p>
</blockquote>
<blockquote>
<h5 id="单选题-在-Reduce-函数中，为什么-values-要用-Iterator-而不是简单的用一个数组？"><a href="#单选题-在-Reduce-函数中，为什么-values-要用-Iterator-而不是简单的用一个数组？" class="headerlink" title="[单选题]在 Reduce 函数中，为什么 values 要用 Iterator 而不是简单的用一个数组？"></a>[单选题]在 Reduce 函数中，为什么 values 要用 Iterator 而不是简单的用一个数组？</h5><p>A.因为作者偏好使用 Iterator0.87% 选择</p>
<p>B.因为数组有可能在内存中会放不下，而 Iterator 具体实现的时候可能是从文件里分批次读取84.87% 选择</p>
<p>C.因为 Iterator 的读取效率比较快4.24% 选择</p>
<p>D.因为 Iterator 是一个接口，可以用数组来实现10.01% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong> B</p>
</blockquote>
<h2 id="Word-Count"><a href="#Word-Count" class="headerlink" title="Word Count"></a>Word Count</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCount</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;str&#125; line a text, for example "Bye Bye see you next"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(self, _, line)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value'</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> line.split():</span><br><span class="line">            <span class="keyword">yield</span> w, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param key is from mapper</span></span><br><span class="line">    <span class="comment"># @param values is a set of value with the same key</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(self, key, values)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value'</span></span><br><span class="line">        <span class="keyword">yield</span> key, sum(values)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(String key, String value, OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, int value);</span></span><br><span class="line">            StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(value);</span><br><span class="line">            <span class="keyword">while</span> (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String outputKey = tokenizer.nextToken();</span><br><span class="line">                output.collect(outputKey, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(String key, Iterator&lt;Integer&gt; values,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, int value);</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (values.hasNext()) &#123;</span><br><span class="line">                sum += values.next();</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="傳輸整理-shuffle"><a href="#傳輸整理-shuffle" class="headerlink" title="傳輸整理 -  shuffle"></a>傳輸整理 -  shuffle</h1><ul>
<li>Partition sort  +  Fetch&amp;Merge</li>
</ul>
<p>當map完怎麼傳給其他機器做reduce?</p>
<ol>
<li>把結果以為key作分組，master有個一致性哈希去作分組。</li>
<li>對組內部作硬盤上的外排序。以key為第一關鍵字，value為第二關鍵字。</li>
<li>３號會再作k路merge，把這些文件合成一個reduce的輸入</li>
</ol>
<blockquote>
<ul>
<li>请问，这里的K路归并需要使用hashmap吗？如果不用的话是如何实现的？如果用的话不是说内存装不下吗？<ul>
<li>k路归并不需要使用hashmap，可以只用少量的内存完成。方法是：每次选取k路中最小的元素，将其放入存放结果的队列，然后重复执行以上两步。存放结果的队列可以直接在硬盘上</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice 1."></a>Practice 1.</h1><p>Inverted Index as Search Engine</p>
<blockquote>
<ul>
<li>一个key占一个reducer吗？还是可以多个key放一个reducer？<ul>
<li>多个key放一个reducer。<br>假设有R个Reducer，map函数产生的key-value pair会被一个hash function(原paper里叫partition function)分成R份，哈希值相同的key会被归到同一个Reducer里，然后Reducer会把这些key-value pair分组，同一个key的value拼在一起之后传给用户编写的reduce函数。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Definition of Document</span></span><br><span class="line"><span class="string">class Document:</span></span><br><span class="line"><span class="string">    def __init__(self, id, cotent):</span></span><br><span class="line"><span class="string">        self.id = id</span></span><br><span class="line"><span class="string">        self.content = content</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedIndex</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;Document&#125; value is a document</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(self, _, value)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="comment"># for word in range(value.content.split()):</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> value.content.split(): </span><br><span class="line">            <span class="keyword">yield</span> word, value.id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param key is from mapper</span></span><br><span class="line">    <span class="comment"># @param values is a set of value with the same key</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(self, key, values)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># # print(type(values))</span></span><br><span class="line">        <span class="comment"># for val in values:</span></span><br><span class="line">        <span class="comment">#     res.append(val)  </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> key, sorted(list(set(values)))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of OutputCollector:</span></span><br><span class="line"><span class="comment"> * class OutputCollector&lt;K, V&gt; &#123;</span></span><br><span class="line"><span class="comment"> *     public void collect(K key, V value);</span></span><br><span class="line"><span class="comment"> *         // Adds a key/value pair to the output buffer</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * Definition of Document:</span></span><br><span class="line"><span class="comment"> * class Document &#123;</span></span><br><span class="line"><span class="comment"> *     public int id;</span></span><br><span class="line"><span class="comment"> *     public String content;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertedIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(String _, Document value,</span></span></span><br><span class="line"><span class="function"><span class="params">                        OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, int value);</span></span><br><span class="line">            <span class="keyword">int</span> id = value.id;</span><br><span class="line">            StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(value.content);</span><br><span class="line">            <span class="keyword">while</span> (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String word = tokenizer.nextToken();</span><br><span class="line">                output.collect(word, id);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(String key, Iterator&lt;Integer&gt; values,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OutputCollector&lt;String, List&lt;Integer&gt;&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, List&lt;Integer&gt; value);</span></span><br><span class="line">            List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> previous = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (values.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">int</span> now = values.next();</span><br><span class="line">                <span class="keyword">if</span>(previous != now) &#123;</span><br><span class="line">                    results.add(now);</span><br><span class="line">                &#125;</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Practice-2"><a href="#Practice-2" class="headerlink" title="Practice 2."></a>Practice 2.</h1><p>Anagram grouping</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anagram</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;str&#125; line a text, for example "Bye Bye see you next"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(self, _, line)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> line.split():</span><br><span class="line">            <span class="comment"># print(word)</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="string">''</span>.join(sorted(word)), word</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param key is from mapper</span></span><br><span class="line">    <span class="comment"># @param values is a set of value with the same key</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(self, key, values)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="keyword">yield</span> key, list(values)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of OutputCollector:</span></span><br><span class="line"><span class="comment"> * class OutputCollector&lt;K, V&gt; &#123;</span></span><br><span class="line"><span class="comment"> *     public void collect(K key, V value);</span></span><br><span class="line"><span class="comment"> *         // Adds a key/value pair to the output buffer</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anagram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(String key, String value, OutputCollector&lt;String, String&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, String value);</span></span><br><span class="line">            StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(value);</span><br><span class="line">            <span class="keyword">while</span> (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String word = tokenizer.nextToken();</span><br><span class="line">                String original = word;</span><br><span class="line">                <span class="keyword">char</span>[] chars = original.toCharArray();</span><br><span class="line">                Arrays.sort(chars);</span><br><span class="line">                String sorted = <span class="keyword">new</span> String(chars);</span><br><span class="line">                output.collect(sorted, word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(String key, Iterator&lt;String&gt; values, OutputCollector&lt;String, List&lt;String&gt;&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, List&lt;String&gt; value);</span></span><br><span class="line">            List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">while</span> (values.hasNext()) &#123;</span><br><span class="line">                results.add(values.next());</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Map’s"><a href="#Map’s" class="headerlink" title="Map’s"></a>Map’s</h3><ul>
<li><p>Key: 經內部字母排序後的單詞 (會一樣)</p>
</li>
<li><p>Value : 未經排序的</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>map结果传输给reducer是不是要通过网络传输？这样的速度够用吗</p>
<ul>
<li>map结果是通过网络传给reducer，map和reducer一般同在一个内网，网速够用</li>
</ul>
</li>
<li><p>mapReduce中master机器不会用于管理所有数据的metadata吗？</p>
<ul>
<li><p>master不负责中间计算结果的相关数据。</p>
</li>
<li><p>再补充几个常见的 QA:</p>
<p>Q: Reduce 之后各个key还是可能会在不同地方，那么怎么再把这些 reducer 的结果 sort 并放在一起呢？<br>A: Reducer 的结果在全局是不 sort 的。因为很多计算场景下计算结果不需要 sort。如果有 sort 的需求，可以使用外排序算法（External Sorting）进行排序即可。</p>
</li>
<li><p>Q: 系统设计中 map reduce 的问题会以什么形式问？<br>A: 90% 的概率会问使用 map reduce 来解决比较重的计算问题。10% 的概率会问 map reduce 的原理是怎么样的。所以好好做今天的编程题作业非常重要！</p>
</li>
<li><p>Q: Reduce 的过程全部都在内存里么？是否会装不下？<br>A: 不是的。Reduce 的过程，key 是在内存里的，value list 通常在代码中是一个 iterator 的形式，也就意味着，有可能是从文件里读进来的。很显然全部放在内存肯定是放不下的，特别是对一些很 hot 的 key。</p>
</li>
<li></li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Practice-3-K-frequent-words"><a href="#Practice-3-K-frequent-words" class="headerlink" title="Practice 3 K-frequent words"></a>Practice 3 K-frequent words</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Definition of Document</span></span><br><span class="line"><span class="string">class Document:</span></span><br><span class="line"><span class="string">    def __init__(self, id, content):</span></span><br><span class="line"><span class="string">        self.id = id</span></span><br><span class="line"><span class="string">        self.content = content</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> Mr_tools <span class="keyword">import</span> Document</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopKFrequentWords</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;Document&#125; value is a document and value have two attributes(id and content)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(self, _, value)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="comment"># key is word and value is 1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> value.content.split():</span><br><span class="line">            <span class="keyword">yield</span> word, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param key is from mapper</span></span><br><span class="line">    <span class="comment"># @param values is a list of document</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(self, key, values)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="comment"># key is word, value is count</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># yield key, reversed(sorted(values))</span></span><br><span class="line">        <span class="keyword">yield</span> key, values   <span class="comment"># 框架天生就已经照 DESC 排好了</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of OutputCollector:</span></span><br><span class="line"><span class="comment"> * class OutputCollector&lt;K, V&gt; &#123;</span></span><br><span class="line"><span class="comment"> *     public void collect(K key, V value);</span></span><br><span class="line"><span class="comment"> *         // Adds a key/value pair to the output buffer</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * Definition of Document:</span></span><br><span class="line"><span class="comment"> * class Document &#123;</span></span><br><span class="line"><span class="comment"> *     public int id;</span></span><br><span class="line"><span class="comment"> *     public String content;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    Pair(String key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKFrequentWords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(String _, Document value,</span></span></span><br><span class="line"><span class="function"><span class="params">                        OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, int value);</span></span><br><span class="line">            <span class="keyword">int</span> id = value.id;</span><br><span class="line">            String content = value.content;</span><br><span class="line">            String[] words = content.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word : words)</span><br><span class="line">                <span class="keyword">if</span> (word.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    output.collect(word, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PriorityQueue&lt;Pair&gt; Q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Comparator&lt;Pair&gt; pairComparator = <span class="keyword">new</span> Comparator&lt;Pair&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair left, Pair right)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (left.value != right.value) &#123;</span><br><span class="line">                    <span class="keyword">return</span> left.value - right.value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> right.key.compareTo(left.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// initialize your data structure here</span></span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            Q = <span class="keyword">new</span> PriorityQueue&lt;Pair&gt;(k, pairComparator);</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(String key, Iterator&lt;Integer&gt; values)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (values.hasNext()) &#123;</span><br><span class="line">                    sum += values.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Pair pair = <span class="keyword">new</span> Pair(key, sum);</span><br><span class="line">            <span class="keyword">if</span> (Q.size() &lt; k) &#123;</span><br><span class="line">                Q.add(pair);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Pair peak = Q.peek();</span><br><span class="line">                <span class="keyword">if</span> (pairComparator.compare(pair, peak) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Q.poll();</span><br><span class="line">                    Q.add(pair);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Output the top k pairs &lt;word, times&gt; into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, Integer value);</span></span><br><span class="line">            List&lt;Pair&gt; pairs = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!Q.isEmpty()) &#123;</span><br><span class="line">                pairs.add(Q.poll());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reverse result</span></span><br><span class="line">            <span class="keyword">int</span> n = pairs.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                Pair pair = pairs.get(i);</span><br><span class="line">                output.collect(pair.key, pair.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NGram</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; n a integer</span></span><br><span class="line">    <span class="comment"># @param &#123;str&#125; string a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(self, _, n, string)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(len(string)-n+<span class="number">1</span>):</span><br><span class="line">            word = string[start:start+n]</span><br><span class="line">            <span class="keyword">yield</span> word, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param key is from mapper</span></span><br><span class="line">    <span class="comment"># @param values is a set of value with the same key</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(self, key, values)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="comment"># Please use 'yield key, value' here</span></span><br><span class="line">        <span class="keyword">yield</span> key, sum(values)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of OutputCollector:</span></span><br><span class="line"><span class="comment"> * class OutputCollector&lt;K, V&gt; &#123;</span></span><br><span class="line"><span class="comment"> *     public void collect(K key, V value);</span></span><br><span class="line"><span class="comment"> *         // Adds a key/value pair to the output buffer</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NGram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(String _, <span class="keyword">int</span> n, String str,</span></span></span><br><span class="line"><span class="function"><span class="params">                        OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, Integer value);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; str.length() - n + <span class="number">1</span>; ++index) &#123;</span><br><span class="line">                output.collect(str.substring(index, index + n), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(String key, Iterator&lt;Integer&gt; values,</span></span></span><br><span class="line"><span class="function"><span class="params">                           OutputCollector&lt;String, Integer&gt; output)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Write your code here</span></span><br><span class="line">            <span class="comment">// Output the results into output buffer.</span></span><br><span class="line">            <span class="comment">// Ps. output.collect(String key, int value);</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (values.hasNext()) &#123;</span><br><span class="line">                    sum += values.next();</span><br><span class="line">            &#125;</span><br><span class="line">            output.collect(key, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><img src="/Users/joe/Library/Application Support/typora-user-images/image-20200419212810217.png" alt="image-20200419212810217" style="zoom: 50%;" />

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzedcrqyjj30k20tyn18.jpg" alt="image-20200419212855454" style="zoom:50%;" />

<blockquote>
<p>1T 的数据很大，通常很难找到内存超过 1T 的电脑。但是内存超过 1G 的还是很容易的。因此 A 肯定是不对的。如果我们能找到一个算法比较均匀的拆分 1T 的数据到 1024 个 1G 的文件的话，每个文件都可以导入内存中进行排序，最后我们再归并排序后的结果即可。这个拆分排序再归并的算法就是外排序算法。</p>
<ul>
<li>选项 B，按照数据的范围进行拆分，会导致分配不均匀，比如大部分的数据都在一个很小的范围内。而且不是所有的数据都有可数范围，如字符串是很难划定范围的。</li>
<li>选项 C，按照 hash 之后的结果进行拆分，也会导致数据拆分不均匀，因而使得某些部分可能依然无法导入内存。</li>
<li>选项 D，按照实际存储位置进行拆分，这样才能够确保每个部分可以导入内存。</li>
</ul>
</blockquote>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420002016032.png" alt="image-20200420002016032" style="zoom:50%;" />

<blockquote>
<ul>
<li>Map 的机器如果没有全部执行完，任何一台 Reduce 的机器所负责的数据段都有可能还有更新。因此 Reduce 的部分是不可以开始的。但是机器可以先启动执行一些程序的初始化操作是可以的。</li>
</ul>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzjbais4qj30ju0v0429.jpg" alt="image-20200420001955882" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420002035928.png" alt="image-20200420002035928" style="zoom:50%;" /></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/15/System-Design/9p/2019-04-15-BigTable/">System-Design/9p/2019-04-15-BigTable</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><ul>
<li>NoSQL DB</li>
<li>SS table 的讀跟寫</li>
<li>Bloom Filter</li>
<li>Look up service</li>
<li>Merge K Sorted Arrays</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 486. Merge K Sorted Arrays</span></span><br><span class="line"><span class="comment"># 中文English</span></span><br><span class="line"><span class="comment"># Given k sorted integer arrays, merge them into one sorted array.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="comment"># Example 1:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Input: </span></span><br><span class="line"><span class="comment">#   [</span></span><br><span class="line"><span class="comment">#     [1, 3, 5, 7],</span></span><br><span class="line"><span class="comment">#     [2, 4, 6],</span></span><br><span class="line"><span class="comment">#     [0, 8, 9, 10, 11]</span></span><br><span class="line"><span class="comment">#   ]</span></span><br><span class="line"><span class="comment"># Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br><span class="line"><span class="comment"># Example 2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Input:</span></span><br><span class="line"><span class="comment">#   [</span></span><br><span class="line"><span class="comment">#     [1,2,3],</span></span><br><span class="line"><span class="comment">#     [1,2]</span></span><br><span class="line"><span class="comment">#   ]</span></span><br><span class="line"><span class="comment"># Output: [1,1,2,2,3]</span></span><br><span class="line"><span class="comment"># Challenge</span></span><br><span class="line"><span class="comment"># Do it in O(N log k).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># N is the total number of integers.</span></span><br><span class="line"><span class="comment"># k is the number of arrays.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param arrays: k sorted integer arrays</span></span><br><span class="line"><span class="string">    @return: a sorted array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergekSortedArrays</span><span class="params">(self, arrays)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.helper_heapq(arrays)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper_heapq</span><span class="params">(self, arrays)</span>:</span></span><br><span class="line">        hp = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(arrays)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> arrays[k]: <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(hp, (arrays[k][<span class="number">0</span>], k, <span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># print(hp)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> hp: </span><br><span class="line">            _, kth, idx = heapq.heappop(hp)</span><br><span class="line">            <span class="comment"># print(val, arrays[kth][idx], kth, idx)</span></span><br><span class="line">            res.append(arrays[kth][idx])</span><br><span class="line">            <span class="keyword">if</span> idx+<span class="number">1</span> &lt;= len(arrays[kth])<span class="number">-1</span>:</span><br><span class="line">                heapq.heappush(hp, (arrays[kth][idx+<span class="number">1</span>], kth, idx+<span class="number">1</span>))</span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment"># 大可以等下一輪拉出來再push那條的下一個元素，不急</span></span><br><span class="line">            <span class="comment">#     # while idx+1 &gt; len(array[kth])-1:</span></span><br><span class="line">            <span class="comment">#     val, kth, idx = heapq.heappop(hp)</span></span><br><span class="line">            <span class="comment">#     res.append(val)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li>Binary Tree Serialization</li>
</ul>
<h1 id="Big-Table"><a href="#Big-Table" class="headerlink" title="Big Table"></a>Big Table</h1><p>Big Table vs GFS</p>
<table>
<thead>
<tr>
<th></th>
<th>GFS</th>
<th>BiGTable</th>
</tr>
</thead>
<tbody><tr>
<td>本質</td>
<td>分布式File System</td>
<td>分布式 NoSQL DB</td>
</tr>
<tr>
<td>開發公司</td>
<td>Google</td>
<td>Google</td>
</tr>
<tr>
<td>是否開源</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>類似開源產品</td>
<td>HDFS</td>
<td>HBase</td>
</tr>
<tr>
<td>操作</td>
<td>Read &amp; Write</td>
<td>CRUD</td>
</tr>
<tr>
<td>類似什麼</td>
<td>家用電腦的文件系統</td>
<td>大數據版的Excel</td>
</tr>
</tbody></table>
<p>結構化文件可上BigTable終究是存上GFS。</p>
<blockquote>
<ul>
<li>BigTable 和 Dremel 主要有什么区别？<ul>
<li>bigtable是nosql storage system，dremel是query system。</li>
</ul>
</li>
<li></li>
</ul>
</blockquote>
<h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><ul>
<li>修改 CUD</li>
<li>查找 R</li>
</ul>
<p>後端通常給web server 使用，Scenario比較單一</p>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>數據庫在邏輯上就是kv型式。硬盤不能存表結構，最終都轉成string去存在disk上。</p>
<p>就是要從文件系統的基礎上去思考搭數據庫系統。</p>
<p>Q: 在文件裡怎麼更好支持查詢操作？</p>
<ol>
<li>把文件硬盤全讀到內存，然後在內存作流程管理</li>
<li>Better, 讀文件進內存後，排序+二分。有什麼問題？==&gt; <ul>
<li>直接在硬盤中對數據作排序 + 硬盤中二分。<ul>
<li>How? 外排序</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Q: 如果有相應的feature有修改操作了，怎辦？</p>
<ol>
<li>直接在文件裡修改？==&gt; 大家都要移動</li>
<li>讀整個文件，修改好後，把原文件刪了，重新寫入新文件。==&gt; 耗時，每次要讀出寫入其他多餘不變的內容</li>
<li>不修改，直接append操作追加一條紀錄。V! ==&gt; 特快！<ul>
<li>怎麼識別最新的紀錄？<ul>
<li>在所有數據後面加個時間戳，時間戳最大的就是真正的我們要找的紀錄</li>
</ul>
</li>
<li>沒順序怎麼二分？<ul>
<li>分塊有序<ul>
<li>每個塊內部有序</li>
<li>寫時候只有最後一塊無序，並且隔一段時間整理成有序。</li>
<li>例：每次寫時就是在最後塊append一條紀錄，for看最後塊有沒有那個值，沒的話就往前一塊作二分查找；每隔時間到就把最後塊給整理成有序下，然後啟新的塊。一個塊是256MB，滿了後就不再寫了。</li>
</ul>
</li>
<li>分塊太多時會有很多重複紀錄啊？如某個feature一直被改改改<ul>
<li>Solution: 把有序塊中作去重，作k路去重merge，如果是根據時間去重，當時間一樣時，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Big Table 為了寫優化，選了３作。</p>
<blockquote>
<ul>
<li>老师，请问，数据库系统不存储数据，所有数据最终都存储在文件系统当中， 数据库只是负责查询和组织诗句是吗<ul>
<li>是的，大多DB都使用现有的文件系统作为底层存储机制</li>
</ul>
</li>
<li>数据库是不是可以建立在任何的文件系统， 还是要为数据库写一个特殊的文件系统以提高效率？<ul>
<li>一般没有必要，使用普通的文件系统在性能上已经足够了。</li>
</ul>
</li>
<li>利用数据库系统查询文件系统的时候 是在写入文件时就将文件里的所有表内容 按key-value的形式 再写入数据库么？<ul>
<li>按特定的数据结构存储，正如你说的key-value的形式，然后写入数据库中</li>
</ul>
</li>
<li>这里除去duplicate的k路归并也是全部读到内存中进行么？每一块中可以有duplicate存在么？<ul>
<li>K路归并的方法在后面的拓展视频中有讲到，每一个块中可以有duplicate</li>
</ul>
</li>
<li>我如果想查找k的值，我怎么知道k在哪个文件里？<ul>
<li>每个文件存储的k都是一个范围内的k值，直接二分搜索找到k在哪个范围内就找到了那个文件</li>
</ul>
</li>
<li>append到文件末尾也会增加文件大小啊，怎么避免和其他文件储存的位置冲突？<ul>
<li>如果是基于文件系统上搭建数据库，不必考虑此问题，操作系统会帮你完成；如果是自己直接基于disk搭建数据库，每个数据块初始化的时候就预先开辟适量的disk空间，当写入增加的数据量超过原有分配的空间的时候就需要申请一块更大的disk空间，将它拷贝过去，然后将原有的空间释放即可。（可以看下操作系统书中有关机械磁盘基本原理的介绍）</li>
</ul>
</li>
<li>直接把修改内容append到最后，这个方法，如果修改得太多了，会不会感觉很乱，每次读的时候cost增加，因为一个file可能有三分之一的size是修修改改？需不需要在修改的量超过一个比例的时候处理一下？<ul>
<li>首先要明确一点的是，没有任何一个数据库是生来都适合所有操作和场景的。也就是说，BigTable 本来就不适合修改特别多的场景。另外 BigTable 这类数据库会定期 Merge sstable，从而消除那些中间态的修改记录。</li>
</ul>
</li>
<li>分块是什么意思？<ul>
<li>是指将指定的“filename” 这个文件分成很多块，然后每次存储的时候找该文件编号的最后一块进行写入。如果写满了 是需要在文件系统里追加写入一个新的对应该文件名的块</li>
</ul>
</li>
<li>在讲到“分块有序”时，老师说到每个块之间都是有序的。但是块与块之间是不是有序的呢？也就是说是不是第1个块的 key 值都小于第2块的 key 值，第2块的 key 值都小于第3块的key值？（最后一块除外）<ul>
<li>块与块之间是有序的。这里可以是key-value存储记录块的索引地址；也可以是B+树索引，方便查找修改。</li>
</ul>
</li>
<li>那每次查询都要查询每一个块吗？不能直接锁定就在哪一个块中（例如索引之类的）？<ul>
<li><strong><em>好问题，后面的视频中讲到了索引，带着问题继续学习，棒！</em></strong></li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="One-Work-Solution"><a href="#One-Work-Solution" class="headerlink" title="One Work Solution"></a>One Work Solution</h1><h3 id="寫入過程"><a href="#寫入過程" class="headerlink" title="寫入過程"></a>寫入過程</h3><p>​    一個無序快快寫滿時，就排序然後寫入到FS。</p>
<ol>
<li>讀入到內存作快排 X</li>
<li>外排序 X;  <ul>
<li>每個文件最多就也256M，一個內存完全可放下，完全不需要外排</li>
</ul>
</li>
<li>可不可一開始就放在內存？V!</li>
</ol>
<p>比方，內存會用跳表這個結構，</p>
<h3 id="機器掛了怎辦？"><a href="#機器掛了怎辦？" class="headerlink" title="機器掛了怎辦？"></a>機器掛了怎辦？</h3><p>Write Ahead Log (WAL)，就只是append而已</p>
<p>append寫disk非常快和一般寫不同，打開模式為寫</p>
<p>如果要把最後一個塊放在硬盤的話，它不只要可以append還要可以read的操作；</p>
<p>append和寫不同，打開如果是append模式時，ptr是在尾巴；如果是寫模式，文件原內容會被清楚，ptr會指在文件頭。</p>
<p>所以：</p>
<p>内存排序+1次硬盘统一写入+1次硬盘写Log</p>
<p>Link: <a href="http://www.larsgeorge.com/2010/01/hbase-architecture-101-write-" target="_blank" rel="noopener">http://www.larsgeorge.com/2010/01/hbase-architecture-101-write-</a> ahead-log.html</p>
<blockquote>
<ul>
<li>每个块最大256M，是Google的Big Table自己定义的吗？还是一种通用的标准呢？而且这个“块”的学名是什么呀？谢谢！<ul>
<li>是的，是官方定义。<br>256M 块的大小是google工程师长期实践的一个经验值，统计过这个值比较合理。<br>最后，块的专业名词为：chunk</li>
</ul>
</li>
<li>什么是硬盘外部排序？<ul>
<li>当参加排序的数的量太大，或内存不足以存放时，需要使用外排序。外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</li>
</ul>
</li>
<li>老师，最后一个块是存在内存里的，存满256MB之后再写入硬盘。请问每次append一条数据到块里，是每次利用二分查找来保证这条数据插入到正确位置，还是每次就直接在块的尾部直接添加数据，直到块满了256MB，再排序变为有序啊。<ul>
<li>直接在尾部添加，直到块满就进行排序。</li>
</ul>
</li>
<li>这里的WAL 不是应该 每次有新的数据到内存都要写一次WAL吗？ 为什么说是1次的硬盘写LOG ？<ul>
<li>是的，Write Ahead Log，就是对内存中Sorted Table里，new append data在HDD做一次append的操作。请再认真听讲，要确认每一个细节，其实再认真听讲是可以找到答案的，老师有讲到此细节。确实有问题了，仔细思考后再提出问题，这样学习深刻。</li>
</ul>
</li>
<li>Write ahead log 为什么是一次， 不应该每次有update 都要写一次吗？<ul>
<li>这块的WAL是多次的数据操作才会触发一次log写操作。这是为了性能的考量，HDD写的速度相比磁头寻道速度还是很快的，不想把太多时间浪费在寻道上，也就是每次写操作就需要寻道一次。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="讀取優化"><a href="#讀取優化" class="headerlink" title="讀取優化"></a>讀取優化</h1><p>本來是只能在FS上作二分，更好的是建index</p>
<ul>
<li>一個簡單的建index 的方法：<ul>
<li>Key<ul>
<li>就不需要整個文件作二分</li>
<li>把一些Key放入內存作為index</li>
<li>Index有效減少磁盤讀寫次數</li>
</ul>
</li>
</ul>
</li>
<li>B-tree Index</li>
</ul>
<blockquote>
<ul>
<li>所以内存中有无序的存储块，和sorted存储块（sorted list），先用for查找无序没有，再去有内存中sorted list上跳跃查找？<ul>
<li>大体思路是对的，详细流程稍微更正如下：<br>(1)query Master server by the key;<br>(2) tablet server（即SSTable slave server）;<br>(3) check skip list(即跳表，在memory中) in the tablet server（对象没有排序的Sorted List）;<br>(4) check bloom filter(memory) for a SSTable(Sorted String Table)（最好一块有序块）;<br>(5) check index(memory) for a SSTable(查找其key的大致范围);<br>(6) find the value in the SSTable(根据在内存index定位到的小范围，在磁盘中通过二分查找这个key的文件内容).</li>
</ul>
</li>
<li>“看到这里我对于建立index又有些迷茫了。本来一个块中就是有序的，直接二分不就行了。就算是先看index，也是要先对index进行二分，再拿着找到的位置去块本身里找东西。那么index的好处是不是因为index比数据本身的size小，所以在index里二分比在数据里二分块？ “<ul>
<li>index 是在内存里的，你在内存里二分 index 比直接去 disk 上二分要快好几十倍。<strong><em>文件操作远远慢于内存操作</em></strong>。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>这里是课上提到的 B-Tree / B+ Tree 的一些资料：</p>
<p>Wiki:<br><a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B-tree</a></p>
<p>以B tree和B+ tree的区别来分析mysql索引实现:<br><a href="https://www.jianshu.com/p/0371c9569736" target="_blank" rel="noopener">https://www.jianshu.com/p/0371c9569736</a></p>
<p>这部分的内容只需要了解原理，不需要代码实现。</p>
</blockquote>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><h3 id="繼續讀優化"><a href="#繼續讀優化" class="headerlink" title="繼續讀優化"></a>繼續讀優化</h3><p>因為寫的時候我們用的是append, 但就是讀的時候被搞亂了，所以讀就要一直優化。</p>
<p>數組長度自己定。</p>
<ul>
<li>多個 hash fn時，還是一樣同個數組在作mapping作查詢。</li>
<li>是可能會有False Positive的；但就是起了filter的作用</li>
<li>精度跟<ol>
<li>加入的字符串數目</li>
<li>hash個字</li>
<li>array長度。</li>
</ol>
</li>
<li>有誤判率計算公式</li>
</ul>
<p><strong><em>先用bloom filter看這個塊有沒有、有的話再用index找key可能在塊中的範圍，再用二分找這個塊裡的值</em></strong>　當然，在這之前是要先做完對最後那個在內存的塊的線性查找。</p>
<h2 id="SS-Table-amp-Skip-List"><a href="#SS-Table-amp-Skip-List" class="headerlink" title="SS Table &amp; Skip List"></a>SS Table &amp; Skip List</h2><ul>
<li>String is Store in the File. </li>
<li>SSTable = Sorted String Table</li>
<li>Sorted List 用 Skip List 实现</li>
</ul>
<ol>
<li>Skip List<br> Code: <a href="https://github.com/petegoodliffe/skip_list" target="_blank" rel="noopener">https://github.com/petegoodliffe/skip_list</a> Wiki: <a href="http://bit.ly/2g0C29a" target="_blank" rel="noopener">http://bit.ly/2g0C29a</a></li>
<li>SSTable<br> Google SSTable Page: <a href="http://bit.ly/1kqwrFe" target="_blank" rel="noopener">http://bit.ly/1kqwrFe</a></li>
</ol>
<blockquote>
<ul>
<li>“比如如果我用64个hash函数，每个文件按256M算(按每行数据256bytes算就是一百万行)。你这里难道把一百万个key都放在bloom filter里么 “<ul>
<li>是的，bloom filter的基本单位是bit，这里记录的是hash后的数字，不是文件，<strong><em>一个字节8bit，大约10w 字节，就是100kb，也就是0.1mb</em></strong>。（为了精度可能需要大概几mb的内存就够了）</li>
</ul>
</li>
<li>之前一小节讲的查一个key在不在这个块里需要先把这个块的index load到内存中再二分。你load index文件的时候不也是O(n)么？不在硬盘上二分是因为磁头移动的时间？所以宁愿先load一整个index file到内存中<ul>
<li>是的，因为磁头寻道时间开销相对内存来说很大。（可以读下《现代操作系统》 5.4 磁盘臂调度算法）为了减少磁头寻道的开销衍生出的一些算法</li>
</ul>
</li>
<li>“算两次hash值是为了防止collision么？可以扩大bloom filter的array大小，这样hash也不容易碰撞，这样可以么？ “<ul>
<li>多个hash function可以减少误判率，扩大array的大小也可以减少误判率</li>
</ul>
</li>
<li>index是B+ tree对吧，那为什么只能找到范围？最后一步，二分搜索在磁盘上进行，不是会非常慢么？<ul>
<li>对的，因为具体的内容要到块当中去找，块里的内容key是用字典序排列的，因此存在相同字母开头的key，所以只能锁定一个范围。锁定这个范围之后就可以二分了，logn的速度可以接受</li>
</ul>
</li>
<li>之前提到BigTable会定期执行Disk Merge Sort，这样不就可以直接对磁盘Blocks二分了吗? 为什么还要设计Bloom Filter？<ul>
<li>有很多请求是需要判断key是否在文件中，HDD二分查找也是log级别的操作，Bloom Filter来过滤掉很多不必要的HDD操作</li>
</ul>
</li>
<li>对于SSTable来说好像Index和Bloomfilter都是想要做一件事。视频的图中为什么两个都需要建立呢？<ul>
<li>Boom Filter是起到快速筛选的，如果Bloom Filter中key存在，那么就可能在此SSTable中存在，如果不存在那么肯定就不存在此有序列块中。当key经过Bloom Filter确定可能存在后，再通过index确定其所限的查找范围，确定后，再去磁盘中进行二分查找。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Scale-Sharding"><a href="#Scale-Sharding" class="headerlink" title="Scale - Sharding"></a>Scale - Sharding</h1><ul>
<li><p>垂直沒那麼好，因為可能也想關心這筆data的其他元素。會增加讀取其他feature的難度。</p>
</li>
<li><h3 id="所以水平-consistent-hashing"><a href="#所以水平-consistent-hashing" class="headerlink" title="所以水平 consistent hashing"></a>所以水平 consistent hashing</h3><ul>
<li>大表被拆成了很多個小表們</li>
</ul>
</li>
</ul>
<h1 id="BigTable的分布式鎖"><a href="#BigTable的分布式鎖" class="headerlink" title="BigTable的分布式鎖"></a>BigTable的分布式鎖</h1><ul>
<li><p>讀寫鎖</p>
<ul>
<li><p>一把鎖，兩種屬性：讀跟寫</p>
<ul>
<li><p>讀鎖：讀的時候上的</p>
</li>
<li><p>寫鎖：寫的時候上的</p>
</li>
<li><p>特性</p>
<ol>
<li><p>線程一加讀鎖成功了，又來了兩個讀線程，可以加鎖成功，可進行讀共享</p>
</li>
<li><p>線程一加寫鎖成功了，又來了兩個讀線程，不能加鎖成功，兩個讀的要block；</p>
<p>寫的時候只允許一個線程對內存作寫操作</p>
</li>
<li><p>線程一加讀鎖成功了，來了寫被block，又來了讀就要被block了；寫的優先級是比較高的，並且線程二來得早線程三就得要等了。</p>
<ol>
<li>讀是共享</li>
<li>寫是獨占</li>
<li>寫的優先級更高</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0l4p7wsnj30nw0nwte3.jpg" alt="image-20200420195125198" style="zoom:50%;" />

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0h80fthij30s00j0n0m.jpg" alt="image-20200420195309119"></p>
<ul>
<li><p>鎖服務器：</p>
<ul>
<li>Master的一致性哈希分配小弟也就這邊執行了</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>如果是多台锁服务器，怎么处理并发呢，或者说这么保证对同一个key的上锁操作在同一台锁服务器上进行呢？也是hash吗？map存在web server 上？<ul>
<li>如果锁是一个cluster，<strong><em>多个节点之间会通过一致性协议来保持同步，对外表现得就像是只有一个节点一样，所以不用担心不一致的问题</em></strong>。</li>
</ul>
</li>
<li>这里的图显示 读 和写的都要LOCK 这个KEY，那不是会神慢吗？ 如果KEY LOCKED了后续怎么样呢？ 写一个RETRY吗？ 如果 很多程序同时读这个 KEY，那都得等待了？<ul>
<li>从安全和数据一致性来说，会相对重要些。lock肯定会慢些，但是这不影响总体的运行效率和用户体验。lock本身就是一个信号量互斥的实现机制，也线程间通信的基础， 详阅<a href="https://en.wikipedia.org/wiki/Lock_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Lock_(computer_science)</a></li>
</ul>
</li>
<li>consistent hash map存在lock server上，那master还有什么作用？<ul>
<li>比如 heatbeat 。还有好多事儿要做呢，除了存储还有计算的工作呀。包括管理很多机器的启动，备份恢复等等。</li>
</ul>
</li>
<li>感觉这个lock server不是distributed lock, 实际上是一个centralized locking service?<ul>
<li>lock service内部是distributed实现的，但对外接口是中心化锁服务。具体使用的是chubby。</li>
</ul>
</li>
<li>如果写入的是一个新key，metadata里面还没有这个key对应的consistent hashing value，这时候的写入过程是什么呢？<ul>
<li>lock server查找有这个key的话锁上-》lock server返回server id-》去tablet server对应id写入-》写入GFS-》成功写入 返回True-》lock server释放锁</li>
</ul>
</li>
<li>请问 summary of write 这张图里的 master， 所以其实没有起到任何作用， master 的功能全部被 lock server代替了么？<ul>
<li>master还是提供分发控制的作用；lock server就是保证数据一致性（同一时间只有一个线程操作）</li>
</ul>
</li>
<li>另外你这个读请求的锁，应该只是block其他的对于这个key的write request吧。如果有很多对这个key的read request怎么办？这种情况下难道不能单机多线程读这个key吗。 虽然这种hot partition的case很多情况下是用户没设计好partition key..<ul>
<li>如果有很多对这个key的read request，系统只能等待，性能确实就会下降很多。如果想提这块的性能，可以使用双指针的方法，数据多份备份，这样这块的性能就会提升，但是数据脏读概率增大了。</li>
</ul>
</li>
<li>读取data这种操作 为何也需要锁 没有锁也没有任何问题吧。<ul>
<li>因为在read的同时可能还有针对同一个对象的updata/delete正在进行，为了防止读数据读到一半数据被删了这种不愉快的事情发生，加锁是必要的。</li>
</ul>
</li>
<li>所以timestamp这个信息是存在lock server上的内存中么？一旦完成了上一个，lock server会向下一个最新的request的server发送消息告诉它，现在unlock了，可以开始处理它的请求了？还是以别的方式做信息交互？<ul>
<li>你说的是对的，不过需要知道的是timestamp在sstable上也会存，便于查找的时候知道哪一个是现在最新的值</li>
</ul>
</li>
<li>如果client 拿到锁之后 还没来得及写就意外挂了， 锁怎么释放？有时间限制吗？<ul>
<li>“A client’s session<br>expires if it is unable to renew its session lease within the<br>lease expiration time. When a client’s session expires, it<br>loses any locks and open handles.” client超时后，会释放锁资源。</li>
</ul>
</li>
<li>Disk 中的 每个SSTable 都有自己的bloomfilter 和 index 吗？ 不同SSTable 的可以不一样吗<ul>
<li>对，这样理解是对的。当TableServer启动后开始服务初始化期间，会读取所有的有序块（SSTable）的Bloom Filer和Index到某个内存区域，以便服务查找。</li>
</ul>
</li>
<li>Lock Server存的metadata的数据来源是哪里呢？从BigTable Master里来的？他们之间怎么交流的呢？<ul>
<li>BigTable Master的key<br>这个系统对外会提供一个接口，接口不可直接操作bigtable master、lock server等，这些操作都是内部同步实现的逻辑<br>通信都是socket，可以考虑之间加上消息队列，直接append提交任务给目标server</li>
</ul>
</li>
<li>the entire process did not involve the master server… are we saying that if we have lock/zookeeper, we dont have to access master when reading and writing?<ul>
<li>only the first time from the a client for request, the master server should handle it, as master server need all the tablet server status for the first time of health-check, later then master server will synchronize/delegate all the tablet server status to locking server for the task hand-over. in that case, master server will move on to focus the health-check only.</li>
</ul>
</li>
<li>分布式锁这里面的“分布式”是什么意思？就是说这个锁适用于处理distributed system里面多台服务器需要对同一个资源进行读写的情形？那么不分布式的锁是怎么回事呢？<ul>
<li>这里的分布式指的是适用于多台服务器试图访问同一资源，相当于多台服务器上的多个进程共享资源。<br>非分布式的锁，就是单机上对资源的访问锁。通常就是线程间的资源共享或者单机上多个进程资源共享，通常使用操作系统提供的基础锁设施就可以完成。</li>
</ul>
</li>
<li>整个write 过程， 那一点是系统最慢的过程？ 同样，整个read 过程哪一点是系统最慢的过程？ 这个分布式锁应该会让系统变慢不少把？<ul>
<li>写的过程中，写满一个SSTable序列化到硬盘的时候相对比较慢，读的时候查引索时相对慢一点。实际在使用时，bigtable会使用一种叫做copy on write(cow)的机制，来保证读写操作的原子性，降低分布式锁对速度的影响</li>
</ul>
</li>
<li>感觉bigtable 这种read 的时候需要一个个SSTable 分别查找的方式不如Cassandra 这种直接一个 consistent hashing ring，一步就能知道data 在哪个node上面快啊？<ul>
<li>bigtable首先会在锁服务器上查一致性哈希表，得到在哪个server上。得知之后，会去那个server上查memtable、bloomfilter、sstable</li>
</ul>
</li>
<li>为什么一开始shard还是要通过master 来进行呢，为什么不能通过Locker 来进行呢<ul>
<li>通过最开始的文件sharding，取得与其负责管辖的tablet servers的建立联系，并且记录其各自的运行情况（alive/not alive）和健康信息。</li>
</ul>
</li>
<li>这里讲的master会shard file是什么意思？以及consistent hashing的map如果是存在 master/lock server的内存里，master/lock挂了怎么办<ul>
<li>shard file是共享文件的意思，就是master所管理的各个node server都可以访问和操作这个文件。<br>以前确出现在master挂掉导致整个集群挂掉的情况，现在master都会加有数据持久化的功能、master备份（主master挂掉，备份master就会启动，基本不影响集群运行）</li>
</ul>
</li>
<li>把metadata放在lock里跟放在master里比有什么优势吗？如果这样做会使系统性能更好，那是为什么呢？<ul>
<li>这里相当于将lock这个服务从master里面拆分了出来，这样肯定好的，master一般就是系统的性能瓶颈，减少master的负载，提高系统性能。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Appendixes"><a href="#Appendixes" class="headerlink" title="Appendixes"></a>Appendixes</h1><h2 id="K-sorted-merge"><a href="#K-sorted-merge" class="headerlink" title="K sorted merge"></a>K sorted merge</h2><p>每次找最小的都要O(K), N個下來就要 O(NxK), 用個heap吧 可O(Nxlg(K))</p>
<h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>一共8G的話，每次load進來2G, 就有四條排好的。可再接用K-sorte merge</p>
<ul>
<li><p>最小可以就維護４個元素</p>
</li>
<li><p>改善heap的效能可用</p>
<ul>
<li><p>敗者樹 可以改善選取最小項的常數項的Ｋ</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0l4pvld7j31460ggwgt.jpg" alt="image-20200420202745772" style="zoom:50%;" />
</li>
<li><p>可用選擇-置換的方法　替換掉每組2G的平均分組，就減了少組數，也就是K的大小更小，跑起來更快；每條長度不等就是</p>
<p><a href="https://www.bilibili.com/video/av69423198/" target="_blank" rel="noopener">https://www.bilibili.com/video/av69423198/</a></p>
<ul>
<li>搭配最佳歸併樹，讓IO次數最少的==&gt;帶權路徑最小：Huffman Tree</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>之前write 过程的去重就是在merge过程将重复的key中老的数据去除就好了对吧。<ul>
<li>Yes</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="GFS-amp-BigTable"><a href="#GFS-amp-BigTable" class="headerlink" title="GFS &amp; BigTable"></a>GFS &amp; BigTable</h2><p>Disk vs Excel</p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><ul>
<li>BST 如果有10億數據怎辦？1Gx4Byte == 4GB<ul>
<li>一顆樹就要4GB，多棵樹肯定不行在內存，長期只能在disk</li>
<li>一次尋軌10ms</li>
<li>順序讀取 80MB/S</li>
</ul>
</li>
</ul>
<p>Methods:</p>
<ol>
<li><p>找一次就要4GB/80MB的時間，不可行</p>
</li>
<li><p>只讀取訪問路徑上的數，就是30多個元素 即 30x10ms = 300ms</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0j7utyd2j314q0eogpr.jpg" alt="image-20200420210210409" style="zoom:67%;" />
</li>
<li><p>把二叉變多叉讓樹高降低！</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0j9nfovbj31460ggk0s.jpg" alt="image-20200420210355659" style="zoom:67%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420211217773.png" alt="image-20200420211217773" style="zoom:67%;" />

<p>17是key, data是一堆的其他的feature；B-Tree 為了存硬盤中的數據設計</p>
</li>
<li><p>B+ </p>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420211622972.png" alt="image-20200420211622972" style="zoom:67%;" />



</li>
</ol>
<h2 id="Bloom-Filter-vs-Hash-Table"><a href="#Bloom-Filter-vs-Hash-Table" class="headerlink" title="Bloom Filter vs Hash Table"></a>Bloom Filter vs Hash Table</h2><p>一種數據結構，跟hash table類似，檢測一個元素在一個集合有沒有出現。</p>
<ul>
<li>區別在 BF 更省空間。Hash還是比較費內存。BloomFilter沒有鏈表，主要是用0/1數組，叫Bit Array，沒有鏈表操作，用到多個hash function。</li>
<li>Hash fn 也不是愈多愈好，這會讓0/1消耗愈快；一般取4~16個，有理論結果。</li>
<li>快速檢測一條紀錄有沒有在某一個大塊之中。</li>
<li>在big table中查大多時候都是沒在某一個小塊，不希望每個小塊都去查二分，小塊其實不小。</li>
<li>hash不是等長結構因為有linked list, 無法直接存出；BF可以存出去，就是個bit array了。</li>
</ul>
<p>當要在兩個超過內存的大file裡找交集的urls時，相比hash一長字串就可以節省很多很多空間；但可能小誤報啦。</p>
<ul>
<li>Counting BF vs Standard BF</li>
<li>數組動態膨脹，依據被標為1超過的比例；但BF不存key, 所以複製不過去，膨脹時就是新舊的bit array都要查。效率不是特別好。。短的話誤報率高</li>
</ul>
<blockquote>
<ul>
<li>一个bit 怎么做加法？<ul>
<li>如果是 Counting bloom filter 的话，每一位就用 int 不用 bit 了。</li>
</ul>
</li>
<li>Bloom filter自动膨胀的时候，能不能把原来的bit array丢掉，把所有数据全部拿来重算一遍？我不理解老师说的不能重算一遍这个点。<ul>
<li>不能。比如你把单词 hello world 放到 bloomfilter 里以后，得到的 bit array 是 <code>[1,0,0,1,0,1,0,0,0,0,1,0,0]</code>，难道你可以根据这些0和1反向推导出是 Hello 和 World 这两个单词么？BF 不可逆。</li>
</ul>
</li>
</ul>
</blockquote>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0l4frsejj311m0fqgpt.jpg" alt="image-20200420214218446" style="zoom:50%;" />



<h2 id="跳跃表-Skip-List"><a href="#跳跃表-Skip-List" class="headerlink" title="跳跃表 Skip List"></a>跳跃表 Skip List</h2><img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420215801422.png" alt="image-20200420215801422" style="zoom:67%;" />

<ul>
<li>為什麼要用跳表？<ul>
<li>是個有序鏈表</li>
<li>可提取一些元素，加一層引索</li>
</ul>
</li>
</ul>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420220446625.png" alt="image-20200420220446625" style="zoom:67%;" />



<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0l405klnj311m0fqgpt.jpg" alt="image-20200420220653019"></p>
<ul>
<li>本質是一個分層鏈錶</li>
</ul>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420123257444.png" alt="image-20200420123257444" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420163656675.png" alt="image-20200420163656675" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200420163734278.png" alt="image-20200420163734278" style="zoom:50%;" /></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/11/System-Design/9p/2019-04-11-Distributed%20System%20GFS/">System-Design/9p/2019-04-11-Distributed System GFS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><ul>
<li>GFS Client</li>
<li>Heart Beat</li>
</ul>
<blockquote>
<p>GFS 采用的是 Master-slave 的架构。他的一些基本设计原理，如 chunk 的设计（对应文件系统中的 block）和普通文件系统是相通的。整套系统的设计是基于一些合理假设的（这些假设都是Google从大量工程实践中总结出来的），其中一条假设就是：“We expect a few million files, each typically 100MB or larger in size”。如果实在需要存很多小文件的话， 其实可以将这些小文件打包成一个大文件然后再存储，只要记录下每个小文件在文件内部的起始字节和大小就行了。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="要解決的問題"><a href="#要解決的問題" class="headerlink" title="要解決的問題"></a>要解決的問題</h2><p>Storage不够、QPS太大的問題</p>
<p>Google 很多小計算機建DFS</p>
<p>ＶＳ</p>
<p>SUN大型、貴的（大家買不起），09年被Oracle收了</p>
<p>GFS、BigTable、MapReduce</p>
<h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><ul>
<li>作為一個文件系統，一定要提供兩種常用的操作：寫跟讀<ul>
<li>寫：要文件名、內容</li>
<li>讀：文件名，返回文件內容</li>
</ul>
</li>
<li>總量，比如1000T，才會上分布式；機器數也是越大越好</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul>
<li><p>如圖書館要有Server、Client。</p>
<p>GFS提供的一個就是讀取，另一個是寫入的服務</p>
</li>
<li><p>Server由多台構建。多台機器間怎麼溝通？</p>
<ol>
<li><p>p2p, 平級溝通</p>
<ul>
<li>一台掛了還可以工作，沒有單點故障問題</li>
<li>缺點：但，大家平級，要常通信保持一致性。</li>
<li>p2p的通信一般是比較難寫的，直覺就是。</li>
</ul>
</li>
<li><p>Master vs Slaves, 老大一致對外，對內分配幹活</p>
<ul>
<li><p>數據易保持一致性。就老大分配</p>
</li>
<li><p>缺點：有單點大哥master掛了，整個系統不work的問題</p>
</li>
<li><p>這是GFS最終的選擇，他是後端的服務，不是前端的，所以掛個一分鐘不會怎樣，就如果master掛了，把master重啟就好了。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<h5 id="单选题-大家猜猜GFS会用哪种设计模式？"><a href="#单选题-大家猜猜GFS会用哪种设计模式？" class="headerlink" title="单选题]大家猜猜GFS会用哪种设计模式？"></a>单选题]大家猜猜GFS会用哪种设计模式？</h5><p>A.社会主义 P2P23.06% 选择</p>
<p>B.资本主义 Master Slave76.94% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是A</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>Master Slave的优势是：<br>设计简单<br>数据很容易保持一致</p>
</blockquote>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul>
<li>大文件存在哪？<ul>
<li>當然是disk，10PB只有disk可以，內存不可能啦</li>
</ul>
</li>
<li>如何存到這個文件系統裡？<ul>
<li>怎麼設計GFS?</li>
<li>怎麼存？如果總量 &lt; 100G？</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="单选题-在-GFS-中，大文件存在哪儿？"><a href="#单选题-在-GFS-中，大文件存在哪儿？" class="headerlink" title="[单选题]在 GFS 中，大文件存在哪儿？"></a>[单选题]在 GFS 中，大文件存在哪儿？</h5><p>A.内存中，读写快！5.03% 选择</p>
<p>B.硬盘中，超大空间！94.97% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
</blockquote>
<ul>
<li>metadata元數據常常被無意識訪問到, 怎麼存好？一般打開文件夾就被動看到了</li>
</ul>
<blockquote>
<h5 id="单选题-Meta-Data应该怎样储存？"><a href="#单选题-Meta-Data应该怎样储存？" class="headerlink" title="[单选题]Meta Data应该怎样储存？"></a>[单选题]Meta Data应该怎样储存？</h5><p>A.所有文件的Meta Data 全放磁盘开头83.51% 选择</p>
<p>B.每个文件的Meta Data都和它的内容放在一起16.49% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是A</p>
<p><strong>正确答案:</strong>A</p>
<p><strong>解析:</strong></p>
<p>全放磁盘开头可以减少磁盘的寻轨时间</p>
</blockquote>
<p>理由跟硬盤的結構有關，機械硬盤的磁頭到軌道有尋軌時間的，一般磁頭跳到要找的位置要10ms</p>
<p>如果是選B，磁頭就要一直跳，100個文件就要10ms*100就一秒了。</p>
<p>A可以一次全讀出去。</p>
<ul>
<li>文件內容怎麼放呢？在磁盤中也有兩種方式：就是要不要把每個文件拆成各小塊交錯放呢？</li>
</ul>
<blockquote>
<h5 id="单选题-文件内容应怎样储存？"><a href="#单选题-文件内容应怎样储存？" class="headerlink" title="[单选题]文件内容应怎样储存？"></a>[单选题]文件内容应怎样储存？</h5><p>A.文件整体存储，所有文件连在一起21.44% 选择</p>
<p>B.将每个文件等分成很多小块后再存78.56% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>等分成很多小块后存储可以方便文件的修改操作</p>
</blockquote>
<p>如果選A的話，當2號文件是10KB這麼大，寫入後變100KB了，怎麼寫？還得把2號先砍了，再往後找一個夠100KB大小的空間寫進去。</p>
<p>選B的話，文件本來就是一小塊一小塊了，<strong>後面要增加90KB的文件就順勢往後寫就OK了</strong>。</p>
<p>一個硬盤就是一個非常大的array；</p>
<p>一般NTFS(win)、XFS(linux)的文件系統裡的默認Block是　<strong><em>4KB</em></strong></p>
<ul>
<li><p>本來的100G如果變成了100TB會遇到什麼問題？</p>
<ul>
<li><p>Block的數量會超多。要拿來儲存block的空間就已經非常大了！</p>
<ul>
<li>100x1024G = 100x 1024x1024M = 100x1024x1024x1024KB = 25x1024x1024x1024 <strong>blocks</strong></li>
</ul>
</li>
<li><p>怎麼改進？ ==&gt; 增加Block的大小。可能就是變成64MB，然後把這個改名叫<strong>Chunk</strong></p>
<ul>
<li><p>優：Reduce size of Metadata，就是筆數變少了</p>
</li>
<li><p>劣：浪費了些小空間，如果我要存的就是個小文章４MB，那也要拿64MB去存，60MB就變成了磁盤碎片浪費了。但就這樣吧。。</p>
<p> 結論：Z &gt; B . </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>对于这个trade off，我感觉十分牵强啊。增加chunk size是为了减少meta data 的数量，但是试想，如果存的文件全是非常非常小，都是几百kb或者几mb的，那这样岂不是更浪费空间，造成大量碎片？<ul>
<li>这个在GFS的paper里面有解释，<strong><em>GFS的设计是基于一些假设的（这些假设都是Google从大量工程实践中总结出来的</em></strong>），其中一条假设就是：“We expect a few million files, each typically 100MB or larger in size”。这是其一。另外，如果实在需要存很多小文件的话， 其实可以将这些小文件打包成一个大文件然后再存储，只要记录下每个小文件在文件内部的起始字节和大小就行了。</li>
</ul>
</li>
<li>如果在写新文件时发现之前预先留给metadata的空间被用完了怎么办呢？<ul>
<li>这时候应该就写不进去了 生产环境应该及时关注磁盘容量告警</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Really-Heavy-Storage"><a href="#Really-Heavy-Storage" class="headerlink" title="Really Heavy Storage"></a>Really Heavy Storage</h3><p>e.g. 10PB存得下嗎？需要多台電腦 Master-Slave工作模式。</p>
<ul>
<li>現在一台服務器現在最多插10個硬盤，一個硬盤撐死就100TB，這樣也就才0.1P，這樣如此的電腦至少要來100台共同工作才能做得了10PB的事</li>
</ul>
<blockquote>
<h5 id="单选题-在-GFS-中-Master-和-Slave-分别存什么数据？"><a href="#单选题-在-GFS-中-Master-和-Slave-分别存什么数据？" class="headerlink" title="[单选题]在 GFS 中 Master 和 Slave 分别存什么数据？"></a>[单选题]在 GFS 中 Master 和 Slave 分别存什么数据？</h5><p>A.Master 存 Metadata，Slave 存实际的文件内容96.81% 选择</p>
<p>B.Master 存实际的文件内容，Slave 存 Metadata3.19% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是A</p>
</blockquote>
<p>Master存了所有的chunk該在哪台小弟的info</p>
<p><strong><em>所以就是slave就是chunk server</em></strong></p>
<blockquote>
<p>[单选题]GFS Master 是否有必要存储每个 chunk 在 Slave Server 上的 Offset?</p>
<p>你的选择:B</p>
<p>A:有必要</p>
<p>B:没有必要</p>
<p>答对了，您选择的答案是B</p>
</blockquote>
<p>這樣可減輕master壓力；而且slave裡面可以自己調整位置不用通跟master通信。</p>
<p><em>１chunk = <strong>64MB need 64B的metadata(經驗值)</strong>, 10PB needs 10G metadata, 存內存都可以！</em></p>
<blockquote>
<ul>
<li>如果master 挂了 只能恢复master ？ 不能promote slave server 变成master？<ul>
<li>GFS 里的 Master 的概念和 MySQL 里的 MasterSlave 的概念不同。GFS 里的 Master 只负责管理，不负责数据存储。MySQL 里的 Master Slave 都只负责数据存储不负责管理。要注意区分。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="寫入怎麼寫好？"><a href="#寫入怎麼寫好？" class="headerlink" title="寫入怎麼寫好？"></a>寫入怎麼寫好？</h4><blockquote>
<h5 id="单选题-怎么将文件写入GFS"><a href="#单选题-怎么将文件写入GFS" class="headerlink" title="[单选题]怎么将文件写入GFS?"></a>[单选题]怎么将文件写入GFS?</h5><p>A.将文件整体一次性写入3.39% 选择</p>
<p>B.将文件拆分成块多次写入96.61% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>不同的块有可能放到不同的Chunk Server，并且分块后方便重传</p>
</blockquote>
<p>如果斷開了，可以從哪斷開的從哪續傳。</p>
<blockquote>
<h5 id="单选题-GFS-Client-将文件拆分为多大进行传输比较合适？"><a href="#单选题-GFS-Client-将文件拆分为多大进行传输比较合适？" class="headerlink" title="[单选题]GFS Client 将文件拆分为多大进行传输比较合适？"></a>[单选题]GFS Client 将文件拆分为多大进行传输比较合适？</h5><p>A.64k6.92% 选择</p>
<p>B.1M5.73% 选择</p>
<p>C.64M83.89% 选择</p>
<p>D.1G3.46% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是C</p>
<p><strong>正确答案:</strong>C</p>
<p><strong>解析:</strong></p>
<p>64M 是一个 chunk 的大小。GFS 是按照 chunk 为单位进行存储的，所以 64M 为一组比较合适。</p>
</blockquote>
<p>傳輸單位也就是chunk。</p>
<blockquote>
<h5 id="单选题-GFS中每一个Chunk怎么写入Server？"><a href="#单选题-GFS中每一个Chunk怎么写入Server？" class="headerlink" title="[单选题]GFS中每一个Chunk怎么写入Server？"></a>[单选题]GFS中每一个Chunk怎么写入Server？</h5><p>A.把文件传给master，让Master处理所有的事情6.81% 选择</p>
<p>B.仅让Master分配Chunk Server，然后直接把Chunk传给相应的Chunk Server93.19% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p><strong><em>避免Master成为瓶颈</em></strong></p>
</blockquote>
<p>master的硬盤有限，網路也是有限的，自己會卡死，分下去給小弟們，讓client間也不會排隊</p>
<ul>
<li>總結：Master要存所有的metadata,  chunkserver存真正的大data 讀要找到對應的chunkserver，寫時要找到空閒的chunkserver；<ul>
<li>寫入是每次找老大問，老大分配空間，自己去找小弟寫</li>
<li>讀出是問老大拿到chunklist，然後去問小弟拿到chunk就ok</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>請問gfs讀取file的話, client會從master得到一個chunk list, 那我並行讀取每個chunk,還是一個一個循序讀取chunk? 有什麼比較快的讀取方法嗎?<ul>
<li>GFS中，Chunk分散储存在若干个Chunk Server中，读取的时候Client可以从不同的Chunk Server同时读取Chunk，相当于有一个并行的效果</li>
</ul>
</li>
<li>The client is the end user side, or another proxy? I don’t think the end user client should worry about which chunk server to write in.<ul>
<li>The “client” mentioned here is a library that is linked to the end user’s application, serving as an <strong><em>abstraction layer between the application and the underlying GFS</em></strong>.</li>
</ul>
</li>
<li>client读取档案时，master server是给他一个chunk list，那client写入档案时，master是给他一个chunk list让他依次写入，还是一个写完master再告知下一个chunk该分配到那个chunk server?<ul>
<li>给一个 chunk list 让他依次写入。否则 master 和 client 之间通信太多很负累，也没啥意义。</li>
</ul>
</li>
<li>client 定义是什么 ？是end user吗？ 还是只是gfs 跟外界的一个interface？<ul>
<li>gfs 和外界的一个 interface。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Scale0"><a href="#Scale0" class="headerlink" title="Scale0"></a>Scale0</h2><blockquote>
<ul>
<li>master down了重启， 是通过读log来恢复吗<ul>
<li>是的，但是一般会定期制作一个checkpoint，挂掉之后只需要从上一个checkpoint开始重放log就行了，不需要每次都从头开始。</li>
</ul>
</li>
<li>master down了之后怎么恢复？<ul>
<li>master down了之后重启就好</li>
</ul>
</li>
<li>老师请问还有其他的加密算法么？还是只能用这个MD5<ul>
<li>有啊，网上搜一大堆。比如 sha1 sha2, sha256.</li>
</ul>
</li>
<li>Check Sum 检查一位错误的例子，如果刚好有两个数据发生改变，是有可能导致xor结果不变的吧。这种情况我们就不知道有文件损坏了？<ul>
<li>是的。check sum 本来就是 false positive 的。你说的这种情况出现概率是很低的。系统设计的领域里面有很多允许 false postive 或者 false negative 的情况，如 BloomFilter 就是一个例子。这些场景下，我们都不能保证 100% work，但是高概率是有效的。这个系统设计区别于算法设计的很大的不同，要注意体会这个地方。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>單master夠嗎？</p>
<ul>
<li>一般都是這樣，大不了就是 Paxos Alg. 的多Master，再多也受不了會有延遲</li>
</ul>
</li>
<li><p>怎麼看資料有掛了</p>
<ul>
<li><p>checksum, md5  哈希，原串發生變化，哈希值就巨大變化，一旦不同，就是原數據必毀</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdtqklpedij31260tun45.jpg" alt="image-20200414235740148" style="zoom: 25%;" />



</li>
</ul>
</li>
</ul>
<ul>
<li><p>也可以用 XOR作checksum, </p>
</li>
<li><p>也可以用SHA1, SHA256, SHA512</p>
</li>
<li><p>也就 4Bytes</p>
</li>
</ul>
<blockquote>
<h5 id="单选题-什么时候写入-checksum"><a href="#单选题-什么时候写入-checksum" class="headerlink" title="[单选题]什么时候写入 checksum?"></a>[单选题]什么时候写入 checksum?</h5><p>A.每个一段时间遍历所有数据计算 checksum 并写入3.32% 选择</p>
<p>B.每个 chunk 在写入的时候计算 checksum 并记录在 chunk 的末尾39.40% 选择</p>
<p>C.每个 chunk 在写入的时候计算 checksum 并集中记录在当前的 Slave 上36.58% 选择</p>
<p>D.每个 chunk 在写入的时候计算 checksum 并集中记录在 Master 上20.70% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
</blockquote>
<blockquote>
<h5 id="单选题-一般来说什么时候检查-checksum？"><a href="#单选题-一般来说什么时候检查-checksum？" class="headerlink" title="[单选题]一般来说什么时候检查 checksum？"></a>[单选题]一般来说什么时候检查 checksum？</h5><p>A.每次读取 chunk 的时候重新计算并对比以前的 checksum90.56% 选择</p>
<p>B.周期性的遍历所有数据检查 checksum9.44% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是A</p>
<p><strong>正确答案:</strong>A</p>
</blockquote>
<p>而且還可以再週期性地檢查；是根據業務調整。</p>
<h4 id="How-to-avoid-data-loss-when-a-Chunk-Server-is-down-fail"><a href="#How-to-avoid-data-loss-when-a-Chunk-Server-is-down-fail" class="headerlink" title="How to avoid data loss when a Chunk Server is down/fail?"></a>How to avoid data loss when a Chunk Server is down/fail?</h4><p>​    Ans: replica 作備份</p>
<blockquote>
<p>​    [单选题]GFS的Replica怎么存放？</p>
<p>1.三个备份都放在一个地方（加州）0.97% 选择</p>
<p>2.三个备份放在三个相隔较远的地方（加州，滨州，纽约州）9.99% 选择</p>
<p>3.两个备份相对比较近，另一个放在较远的地方（2个加州，1个滨州）89.04% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是3</p>
<p><strong>正确答案:</strong>3</p>
<p><strong>解析:</strong></p>
<p>两个备份较近，保证出错时快速恢复，一个较远，保证安全性</p>
</blockquote>
<h4 id="How-to-recover-when-a-chunk-is-broken"><a href="#How-to-recover-when-a-chunk-is-broken" class="headerlink" title="How to recover when a chunk is broken?"></a>How to recover when a chunk is broken?</h4><p>讓Master 幫, Master知道他所有的小弟在哪，</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="如何知道有個小弟完全掛了？-gt-心跳"><a href="#如何知道有個小弟完全掛了？-gt-心跳" class="headerlink" title="如何知道有個小弟完全掛了？==&gt; 心跳"></a>如何知道有個小弟完全掛了？==&gt; 心跳</h4><blockquote>
<h5 id="单选题-心跳（Heartbeat）机制怎么设计？"><a href="#单选题-心跳（Heartbeat）机制怎么设计？" class="headerlink" title="[单选题]心跳（Heartbeat）机制怎么设计？"></a>[单选题]心跳（Heartbeat）机制怎么设计？</h5><p>A.Master 轮询 Chunk Server13.62% 选择</p>
<p>B.Chunk Server 主动向 Master 汇报86.38% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>主动汇报可以减少通信次数，就一次，不然要兩次。</p>
</blockquote>
<h2 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h2><p>寫怎麼寫？client 把chunk一次傳給三個小弟作replica後，client會變成瓶頸…</p>
<blockquote>
<h5 id="单选题-如何解决-client-传输-replica-chunk-的问题？"><a href="#单选题-如何解决-client-传输-replica-chunk-的问题？" class="headerlink" title="[单选题]如何解决 client 传输 replica chunk 的问题？"></a>[单选题]如何解决 client 传输 replica chunk 的问题？</h5><p>A.client 将 chunk 传给 master，由 master 去纷发到 3 台 chunk server6.24% 选择</p>
<p>B.client 将 chunk 传给其中一台 chunk server，然后由这台 chunk server 再传给另外的 2 台63.29% 选择</p>
<p>C.client 将 chunk 传给其中一台 chunk server，另外的两个 chunk server 空了再慢慢传30.47% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
</blockquote>
<p>內網自己傳肯定快得多</p>
<h4 id="怎麼選隊長？"><a href="#怎麼選隊長？" class="headerlink" title="怎麼選隊長？"></a>怎麼選隊長？</h4><blockquote>
<h5 id="多选题-下列哪些因素是我们挑选-chunk-server-队长时所需要考虑的"><a href="#多选题-下列哪些因素是我们挑选-chunk-server-队长时所需要考虑的" class="headerlink" title="[多选题]下列哪些因素是我们挑选 chunk server 队长时所需要考虑的"></a>[多选题]下列哪些因素是我们挑选 chunk server 队长时所需要考虑的</h5><p>A.机器的繁忙程度38.48% 选择</p>
<p>B.距离的远近36.78% 选择</p>
<p>C.剩余存储空间的大小13.27% 选择</p>
<p>D.CPU 的个数11.47% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是B</p>
<p><strong>正确答案:</strong>AB</p>
</blockquote>
<blockquote>
<h5 id="单选题-每次找的-chunk-server-队长是一样的么？"><a href="#单选题-每次找的-chunk-server-队长是一样的么？" class="headerlink" title="[单选题]每次找的 chunk server 队长是一样的么？"></a>[单选题]每次找的 chunk server 队长是一样的么？</h5><p>A.是1.55% 选择</p>
<p>B.不是20.48% 选择</p>
<p>C.不一定77.97% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是C</p>
<p><strong>正确答案:</strong>C</p>
</blockquote>
<h2 id="GFS-problem"><a href="#GFS-problem" class="headerlink" title="GFS problem"></a>GFS problem</h2><p><a href="https://www.jiuzhang.com/qa/627/" target="_blank" rel="noopener">https://www.jiuzhang.com/qa/627/</a></p>
<blockquote>
<ul>
<li><p>设计一个只读的lookup service. 后台的数据是10 billion个key-value pair, 服务形式是接受用户输入的key，返回对应的value。已知每个key的size是0.1kB，每个value的size是1kB。要求系统qps &gt;= 5000，latency &lt; 200ms.</p>
<p>server性能参数需要自己问，我当时只问了这些，可能有需要的但是没有问到的……<br>commodity server<br>8X CPU cores on each server<br>32G memory<br>6T disk</p>
<p>使用任意数量的server，设计这个service。</p>
<p>就不发我的解法了，真的很渣……=。=|||</p>
<ul>
<li><p>我总结了SG_SWE_GM以及其他同学的解答，在此基础上我的想法如下，有问题的地方还请老师同学指正，</p>
<p>=&gt; total key size ~ 10 billion * 0.1kB = 1T<br>=&gt; total value size ~ 10 billion * 1kB = 10T<br>所以每台服务器用两块硬盘，共12T。数据结构用SSTable就好了。</p>
<p>充分利用内存，本来我想用binary search tree做index，但是仔细想想这个服务是只读的，而且硬盘存储键值对用的是SSTable是有序的，key和value长度又是固定的，所以直接把key以有序的方式存在内存就好了，查询的时候对key进行binary search，然后用key在内存中的offset来计算键值对在硬盘中的offset。1T/32G = 31.25. 所以一共需要32台服务器的内存分担key index。前面加一个master负责管理consistent hasing。lg(32G) = 35, 平均查询一个key就算18次内存访问，大约才1800ns，在ms这个量级上可以忽略。</p>
<p>每一次request，在硬盘上读取1kB value的时间：<strong><em>10ms(disk seek)</em></strong> + 4ms(rotation delay for 7200rpm) + 1kB/1MB * <strong><em>30ms(reading 1kB sequentially from disk)</em></strong> = 14ms. 目前一台server能处理的的QPS: 1000ms/14ms = 71, 总的QPS: 71 * 32 = 2272。距离要求还有两倍多的差距。所以我们可以给每台server装上6个6T硬盘，组成3套数据硬盘，3套硬盘可以并行处理3个请求，这样也算是稍微利用了一下8X的多核CPU。这时QPS即为2272 * 3=6816.</p>
<p>延迟：</p>
<ol>
<li>master内存查找consistent hashing map的时间：忽略</li>
<li>master与slave的round trip delay：1 round trip in the same data center is 1ms.</li>
<li>slave内存index查询时间：忽略</li>
<li>slave硬盘读取时间：14ms</li>
</ol>
<p>so total latency is 15ms。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p><strong><em>30ms(reading 1kB sequentially from disk)</em></strong></p>
<ul>
<li>是因為硬盤估計每秒可讀30MB的數據，所以1MB就是30ms；這個讀了１kB的話就0.03 ms跟disk seek比起來可以不計。</li>
</ul>
</li>
<li><p>QPS on 1 server : 1s/10ms 次（一秒一台可以100次。） * 2disk = 200次</p>
</li>
<li><p>5000個QPS/200就需要25台服務器</p>
</li>
</ul>
<h4 id="Latency"><a href="#Latency" class="headerlink" title="Latency:"></a>Latency:</h4><ol>
<li>找到key : 硬盤中作二分查找，每次的主要的是找的時間。</li>
<li>讀到value很小，每次的可以忽略</li>
</ol>
<ul>
<li>Sol1.</li>
</ul>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200412220508731.png" alt="image-20200412220508731" style="zoom:50%;" />

<ul>
<li><input disabled="" type="checkbox"> 分析：log該以2為底，所以就變30 * 10ms(每動一次就要10ms) 就是 300ms, 超過題目規定的200ms，找到key的工作只能在硬盤上做，而且單個硬盤不能並行執行，所以一次query 至少要300ms了，一個硬盤１秒內只能做三次，兩個只能做六次，所以要5000QPS要至少約1000台服務器。這跟他給出的25台差很多！</li>
<li><input disabled="" type="checkbox"> 我們最希望減少的就是300ms的查詢時間；而我們未用上他的內存，一台有32G，<strong><em>40</em></strong>台就有超1TB，就跟所有的數據key量一樣了，所以提示了可以在內存作操作，把所有key都存過去。如果內存中有個內存到硬盤位置的映射的話…！</li>
<li><input disabled="" type="checkbox"> 一個key 0.1kB , 一個position 8Byte，所以一筆仍是0.1kB, 10個billion也是用1TB的內存。所以40台的內存並一起變一個大內存裡直接二分查找就快，每次的時間比硬盤的10ms少到幾乎可不計。</li>
<li><input disabled="" type="checkbox"> 內存去對應硬盤的position。</li>
<li><input disabled="" type="checkbox"> 硬盤二分查找每次要花10ms (disk seek)，但內存不用時間。雖一樣是花30次。所以300ms就省了。所以整體10ms + 0.5ms 就10.5ms。</li>
<li><input disabled="" type="checkbox"> 現在已有40台機器，每台有兩個硬盤，而且每台機器的硬盤可以存下全量的數據 ( 就key啦，就 1T而已)，就是說整體的數據一共有40份拷貝，每個硬盤要花約10ms查找一次，一台可以200次操作(一台有兩顆disk)，40台可以並行作，所以就是8000QPS &gt; 5000QPS!</li>
<li><input disabled="" type="checkbox"> 總結：一共４０台機器，內存就是４０台合併起來當一大塊用，內存大小是１TB；它存放的是key到硬盤中position的數據。每台兩個硬盤，硬盤中存的是全量的數據，一次查找的過程就是，首先通過整體的內存找到在硬盤上的某個位置，均衡負載到40台的某個機器上，讀它的key, value，因為在內存查的時間可以不計，所以最後的延遲就在disk seek時間10ms還有整體在網路上傳輸的0.5ms。</li>
</ul>
<blockquote>
<ul>
<li>key 1T value 10T 机器6T 为啥一台机器的硬盘可以存下全部的信息？<ul>
<li>key 1T + value 10T = 11T<br>一块硬盘6T，一台机器两块硬盘即可存下</li>
</ul>
</li>
<li>为什么一个硬盘能存全量数据？一个硬盘是6TB，key加value需要11TB。如果是两块硬盘存下所有数据，那应该就是100次，为什么是100*2？<ul>
<li>是2块硬盘存下所有数据，每块存一半。100 * 2 的意思是，你有 2 块一瓶，一块硬盘能够提供 100 IOPS，两块就是 200 IOPS，因为你可以并发嘛。</li>
</ul>
</li>
<li>请问，内存是在不同的40台机器上，如何垮机器二分查找呢？机器间通信延迟怎么可以忽略呢？<ul>
<li>40台机器的内存合并起来看成一个大内存。打个比方，一次查找时可以先去编号20的机器上看，如果大了，再去10号机器上看，如果大了，再去5号机器上看。。。。依次类推。40台机器接在一个交换机（switch）上，通信延迟可以做到很低，如果再配合内核旁路，两台机器内存到内存的延迟最低可以做到接近纳秒级别</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="GFS-QA"><a href="#GFS-QA" class="headerlink" title="GFS QA"></a>GFS QA</h2><ul>
<li>硬盤的一個block默認就4KB, as an array in disk</li>
<li>Checksum ，也紀錄下和, 可用md5算hash<ul>
<li>可能會有False Positive, 比如 1,4 两个数据，check sum = 5，但是 2 + 3 也是 5。所以 check sum 相同不能证明数据一定没有发生变化。但是 check sum 不同就表示原始数据肯定发生了变化。因此 check sum 是存在 False Positive 但不存在 False Negative 的。</li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/10/System-Design/9p/2019-04-09-Design%20Chat%20System/">System-Design/9p/2019-04-09-Design Chat System</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><h1 id="Pre-requisite"><a href="#Pre-requisite" class="headerlink" title="Pre-requisite"></a>Pre-requisite</h1><h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><ul>
<li>把RAM裡的數據存上disk或傳輸，如array ==&gt; “[1, 2, 3]”<ul>
<li>不能讓別人來自己的RAM拿，重開機也都不同了</li>
</ul>
</li>
<li>不同類可以定義不同。</li>
<li>java 的 toString() 只是要打出來看，沒要反序列化，不見得算是</li>
<li>如果序列化沒要給人看，還會考慮盡量小<ul>
<li>FB有 thrift，是一個RPC的庫，可做序列化、反序列化，可壓縮數據，如定義一個class結構，只要我的obj是滿足那個類的，就可以丟進去，肉眼不可讀，壓縮率高。當我們加屬性，反序列化還要不出錯！</li>
<li>Google有protobuf。類似的事。</li>
</ul>
</li>
<li>JSON / XML (Web1.0、Android),<ul>
<li>現在Web都是JSON，空間小，可讀</li>
<li>如POST過來有各屬性及其對應的values </li>
</ul>
</li>
</ul>
<h2 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h2><ul>
<li>cookie 客戶端<ul>
<li>把 Token放在Cookie裡，長度有限制的，一般跟身份認證有關。</li>
<li>CSRF 偽造用戶的表單；當post來的時候必帶CSRF，當生成網頁時才會生成，有一定時間如５分鐘內。動態碼去避免攻擊</li>
<li>可設有效期</li>
</ul>
</li>
<li>Session 服務器<ul>
<li>Authentication Token </li>
<li>Session Table 存 Authentication Token，看哪個用戶登入了</li>
<li>一般存在數據庫裡較多</li>
</ul>
</li>
</ul>
<h2 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h2><ul>
<li><p>是個Queue, FIFO</p>
</li>
<li><ol>
<li>任務慢. 2. 需要重試</li>
</ol>
</li>
<li><p>消息隊列不放聊天的消息；一般是放任務ID之類的</p>
</li>
<li><p>生產者、消費者模型 – 多線程題</p>
<ul>
<li>兩邊速率不一致</li>
<li>倉庫就是緩衝</li>
</ul>
</li>
<li><p>Web 用 MQ緩衝，worker 去拿 MQ，好了後worker寫到DB，Web自己去刷新或時不時看下DB</p>
<ul>
<li>Cache, DB 都是最基本構成</li>
</ul>
</li>
<li><p>評測機 - 生產消費者、MQ</p>
</li>
<li><p>發email - 要是發失敗的話，也是MQ可以幫忙的</p>
</li>
<li><p>一般常用的</p>
<ul>
<li>RabbitMQ, </li>
<li>Redis 什麼都會一點，可當數據庫(比不過SQL, NoSQL)、緩存(比不過Memcached)、消息隊列(比不過RabbitMQ)；但速度比較快，內存級別速度，存取效率非常快</li>
<li>AWS Simple Queue Service 消息隊列的雲服務；保證兩個worker拿不會有不同人重覆處理。浪費，也可能有問題如重覆扣錢。螞蟻是處理萬億級別的，用的消息隊列機制很牛。</li>
</ul>
</li>
<li><p>鏡像機制，兩台MQ一直作鏡像，一台專門copy，雙Master, 同時分擔讀和寫</p>
</li>
<li><p>重試機制。</p>
</li>
<li><p>12306一定會有message queue，一堆的請求不會馬上被解決掉，看先來後到。</p>
</li>
<li><p>可設優先級</p>
</li>
<li><p>可有子queue。如登機時不同的排隊。隊列之間是可以併發的，但同一個隊列是FIFO的</p>
</li>
</ul>
<blockquote>
<ul>
<li>消息队列 - AWS SQS 和GCP Cloud pub/sub</li>
<li>kafka做message queue的场景也挺多的吧。<ul>
<li>是的</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="Chat-System"><a href="#Chat-System" class="headerlink" title="Chat System"></a>Chat System</h1><blockquote>
<p>[单选投票题]微信是点对点通信么？</p>
<p>你的选择:B</p>
<p>感谢您参与投票！</p>
<p>A:是的(20.62% 选择)</p>
<p>B:不是(79.38% 选择)</p>
</blockquote>
<h2 id="Message-Service-gt-Storage"><a href="#Message-Service-gt-Storage" class="headerlink" title="Message Service == &gt; Storage"></a>Message Service == &gt; Storage</h2><blockquote>
<h5 id="多选投票题-我们需要在聊天软件的Message-Table里存储什么？"><a href="#多选投票题-我们需要在聊天软件的Message-Table里存储什么？" class="headerlink" title="[多选投票题]我们需要在聊天软件的Message Table里存储什么？"></a>[多选投票题]我们需要在聊天软件的Message Table里存储什么？</h5><p>您选择的答案是ABCDEG</p>
<p>感谢您参与投票！</p>
<p>A.消息的主键 id14.74% 选择</p>
<p>B.发送人15.94% 选择</p>
<p>C.收件人15.67% 选择</p>
<p>D.ip 地址2.66% 选择</p>
<p>E.发送时间16.09% 选择</p>
<p>F.信息类型11.38% 选择</p>
<p>G.信息内容14.84% 选择</p>
<p>H.会话 id8.69% 选择</p>
</blockquote>
<p>表單的設計很重要，不然效率太差。</p>
<h2 id="增加-Thread-Table"><a href="#增加-Thread-Table" class="headerlink" title="增加 Thread Table"></a>增加 Thread Table</h2><p>不用 Session這個字，而用Thread, 就是一個Conversation。</p>
<blockquote>
<h5 id="单选题-这样的Thread-Table有什么问题？"><a href="#单选题-这样的Thread-Table有什么问题？" class="headerlink" title="[单选题]这样的Thread Table有什么问题？"></a>[单选题]这样的Thread Table有什么问题？</h5><p>A.信息会有遗漏12.08% 选择</p>
<p>B.信息查询比较慢50.14% 选择</p>
<p>C.有些信息是私有的37.78% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是B</p>
<p><strong>正确答案:</strong>C　－－　如你讀了但我還沒讀但群裡對我而言就變已讀</p>
</blockquote>
<blockquote>
<ul>
<li>假如需要知道A&amp;B之间的对话历史 怎么知道他们的thread ID呢<ul>
<li>可以根据 participant_hash_code 去反向查询到 thread_id。课里有讲到。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="拆，加User-Thread-Table"><a href="#拆，加User-Thread-Table" class="headerlink" title="拆，加User Thread Table"></a>拆，加User Thread Table</h2><blockquote>
<ul>
<li>存last_message 是为了显示在界面上面吗？<ul>
<li>yes</li>
</ul>
</li>
<li>为什么用id做primary key做sharding会影响效率？<ul>
<li>因为一般我们查询UserThread都是根据user_id去查的，因此要按照user_id来做sharding，这样当我们想获取某一个用户的所有thread_id的时候，就可以直接计算出数据所在的shard。如果用id来做sharding的话，就只能广播到每一台机器查询，然后再汇总结果。</li>
</ul>
</li>
<li>为什么这里直接就用了SQL型数据库？noSQL完全不能用吗？<ul>
<li>用 NoSQL 和 SQL 都可以的。这个课里的观点一直都是，你喜欢用哪个就用哪个。很少一定要用 SQL 或者一定要用 NoSQL。这里会讲解按照 SQL 是如何存储的，后面会讲解按照 NoSQL 是如何存储的，两种方法都可以。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h5 id="单选题-这样的存储方式有什么弊端？"><a href="#单选题-这样的存储方式有什么弊端？" class="headerlink" title="[单选题]这样的存储方式有什么弊端？"></a>[单选题]这样的存储方式有什么弊端？</h5><p>A.需要跨表查询比较慢63.87% 选择</p>
<p>B.信息会有遗漏5.72% 选择</p>
<p>C.限制sharding效率30.41% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是A</p>
<p><strong>正确答案:</strong>A</p>
</blockquote>
<p><strong>跨表用到 JOIN就會慢，要解決掉…</strong></p>
<h2 id="合，"><a href="#合，" class="headerlink" title="合，"></a>合，</h2><p>把公有復制到每個人裡去</p>
<p>這樣做時，當要拿當前用戶資料時，就可以一張表出來，不用再做JOIN；但也有壞處</p>
<blockquote>
<h5 id="多选题-全部放在一个-UserThread-表单里有什么坏处？"><a href="#多选题-全部放在一个-UserThread-表单里有什么坏处？" class="headerlink" title="[多选题]全部放在一个 UserThread 表单里有什么坏处？"></a>[多选题]全部放在一个 UserThread 表单里有什么坏处？</h5><p>A.需要跨表查询比较慢3.02% 选择</p>
<p>B.冗余存储50.89% 选择</p>
<p>C.更新可能会造成的数据不一致问题41.56% 选择</p>
<p>D.信息会有遗漏4.53% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是BC</p>
<p><strong>正确答案:</strong>BC</p>
</blockquote>
<p>Updated_at 雖是共享，也是分在每個裡，因為要用他做排序</p>
<p>更新操作是避不開的。</p>
<blockquote>
<ul>
<li>这里合成一张表算denormalization吗？<ul>
<li>Yes</li>
</ul>
</li>
<li>能两全吗？<ul>
<li>系统设计很多都是trade off，如果有完美的方法我们肯定会优先用完美的方法的，这里的话只能是选定一个方案然后再用一些手段(比如Cache)去减轻其缺点带来的影响。</li>
</ul>
</li>
<li>这算不算在内存里做JOIN操作？<ul>
<li>可以这么理解。</li>
</ul>
</li>
<li>所以在面试中是不是用SQL数据库比较好分析这个题？面试官如果没有要求用noSQL就不要提？<ul>
<li>看你更熟悉哪个。其实 Chat System 是更适合使用 NoSQL 的。你设计的时候用 SQL 问题也不大。面试官一般会根据需要向你针对性提问的。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>所以比較下來，拆還是比較清晰，Thread、用戶分開，比較 DECOUPLE，如果問到 JOIN 再用「合」放在一起，復制幾份，反正字節字不多，全拿出來不用再JOIN。實際工程去 Cache拿，避開 JOIN</strong></p>
<h2 id="怎麼查-Thread-ID"><a href="#怎麼查-Thread-ID" class="headerlink" title="怎麼查 Thread ID?"></a>怎麼查 Thread ID?</h2><p>當用戶發信息時或建群聊時，所以要針對現有看是否他們有現有群</p>
<ul>
<li>用參與者查有沒有他們的Thread<ul>
<li>可樣在 Tread Table 增加一個 participants_hash_code，這樣有以前的群就可以找到<ul>
<li>user排好序後，大家串一起做個uuid，看有沒有以前的群</li>
<li>可以把這個uuid作index查就很快</li>
<li>為何要hash? 群聊太長啦</li>
<li>uuid就不用去考慮相撞，概率不可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>群聊的话可以有新的用户加进来，这时候要更改这个hash code吧？<ul>
<li>Yes</li>
</ul>
</li>
<li>如果有些群聊有人加入有人退出怎么办？participant_hash_code也要改变吗？<ul>
<li>Yes, 也要改變。</li>
</ul>
</li>
<li>如果participant更新是不是要重新generate uuid？<ul>
<li>是的，需要重新生成 participant_hash_code</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Message-Table-表單結構"><a href="#Message-Table-表單結構" class="headerlink" title="Message Table 表單結構"></a>Message Table 表單結構</h2><p>用戶就是一直聊一直聊</p>
<p>要找寫快的，所以NoSQL, 有機會 1.5M QPS，檢索就是 kv。</p>
<blockquote>
<h5 id="单选题-需要查询thread里的message时sharding-key（row-key）是什么？"><a href="#单选题-需要查询thread里的message时sharding-key（row-key）是什么？" class="headerlink" title="[单选题]需要查询thread里的message时sharding key（row key）是什么？"></a>[单选题]需要查询thread里的message时sharding key（row key）是什么？</h5><p>A.user_id11.42% 选择</p>
<p>B.created_at9.40% 选择</p>
<p>C.thread_id56.81% 选择</p>
<p>D.participant_hash_code22.36% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是D</p>
<p><strong>正确答案:</strong>C</p>
</blockquote>
<blockquote>
<ul>
<li>支持消息撤回(recall)的话，一条消息在还允许撤回的这个time window里，也是写在message table里吗？具体撤回是怎么实现的呢？<ul>
<li>增加一个类型的 message，这种 message 就表示要撤回哪条信息。然后客户端拿到这样的信息以后在客户端把消息隐藏掉。这里可能有另外一种容易想到的但是是错的方法是给 message 增加一个是否被撤回了的标记。这种方法有问题的原因是，一般 mobile client 上的信息更新都是增量式的，也就是说，一旦一个消息被下载下来，会在 client 端里也存储一份，并且不会再去检测这条消息是否有被更新过（否则那 client和 server 负担就都大了）因此需要通过“增量式”的方式来更新这条数据的信息，那么自然就是通过一条新的 message 来撤回老的 message。</li>
</ul>
</li>
<li>在cassandra里，可以理解为row key 就是等于 sharding key 吗？有任何反例吗？<ul>
<li>row_key = sharding_key 没错，没有反例，就是一个东西的不同称呼。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="NoSQL-with-Thread-Table"><a href="#NoSQL-with-Thread-Table" class="headerlink" title="NoSQL with Thread Table"></a>NoSQL with Thread Table</h2><p>也可以用SQL，兩者都Ok。</p>
<p>index by thread_id 以及 participant_hash_code</p>
<blockquote>
<h5 id="单选题-Thread-Table-如果使用-NoSQL-该如何存储？"><a href="#单选题-Thread-Table-如果使用-NoSQL-该如何存储？" class="headerlink" title="[单选题]Thread Table 如果使用 NoSQL 该如何存储？"></a>[单选题]Thread Table 如果使用 NoSQL 该如何存储？</h5><p>A.一张表单，row_key为 user_id3.44% 选择</p>
<p>B.两张表单，row_key为 participant_hash_code 和 user_id7.07% 选择</p>
<p>C.两张表单，row_key分别为 thread_id 和 user_id21.41% 选择</p>
<p>D.两张表单，row_key分别为 thread_id 和 participant_hash_code68.07% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是D</p>
<p><strong>正确答案:</strong>D</p>
</blockquote>
<p>用雙表去模擬SQL的單表雙index(背後也是幫建表加速)</p>
<p>也不range query就不用 column, 所以可以就 RocksDB</p>
<blockquote>
<ul>
<li>可以根据created_at来排序column_key 吗？这样可以找到最新20条消息？<ul>
<li>这个其实可以在获取完thread列表之后再按照last_message的时间戳在客户端进行排序，这个排序工作量很小，不需要在服务端做。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="NoSQL-for-User-Table"><a href="#NoSQL-for-User-Table" class="headerlink" title="NoSQL for User Table"></a>NoSQL for User Table</h2><blockquote>
<h5 id="单选题-UserThread-Table-用什么做sharding-key（row-key）？"><a href="#单选题-UserThread-Table-用什么做sharding-key（row-key）？" class="headerlink" title="[单选题]UserThread Table 用什么做sharding key（row key）？"></a>[单选题]UserThread Table 用什么做sharding key（row key）？</h5><p>A.user_id68.04% 选择</p>
<p>B.created_at1.37% 选择</p>
<p>C.thread_id24.24% 选择</p>
<p>D.participant_hash_code6.35% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是C</p>
<p><strong>正确答案:</strong>A</p>
</blockquote>
<p>怎麼取就怎麼sharding…</p>
<blockquote>
<ul>
<li>当web server收到一条群聊的消息，他要怎么知道要往哪些用户发送呢？方法1的thread table已经没有participant_user_ids，只能靠user thread table来得知有谁是属于这个thread。但是user thread table的sharding row key是user id，所以如果要查询participant list，只能scan完所有的user 才能知道谁是属于这个thread。<ul>
<li>需要增加一个 ThreadParticipant 的 Table。记录谁参与了哪些 Thread。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><p>B polling</p>
<p>每隔一段時間的PULL就是POLL</p>
<h2 id="Scale-GCM-amp-APNS"><a href="#Scale-GCM-amp-APNS" class="headerlink" title="Scale, GCM &amp; APNS"></a>Scale, GCM &amp; APNS</h2><ul>
<li>怎麼讓消息更實時？<ul>
<li>PUSH NOTIFICATION</li>
</ul>
</li>
<li>PUSH: 手機上<ul>
<li>Android GCM (Google Cloud Messaging)</li>
<li>Windows 也有它自己的推送系統</li>
<li>iOS APNS (Apple Push Notification Service)<ul>
<li>不同的手機有device token, app註冊完會有, APNS會發給手機, server 拿這個當 push token 去推送給 B，B再過去取 Web Server 取。局限性呢？</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="单选题-这样的方法有什么局限性？"><a href="#单选题-这样的方法有什么局限性？" class="headerlink" title="[单选题]这样的方法有什么局限性？"></a>[单选题]这样的方法有什么局限性？</h5><p>A.获取新消息时可能有延迟26.92% 选择</p>
<p>B.数据库压力过大10.22% 选择</p>
<p>C.消息丢失概率大12.08% 选择</p>
<p>D.无法支持web端50.79% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是D</p>
<p><strong>正确答案:</strong>D</p>
</blockquote>
<blockquote>
<ul>
<li>这个push notification system在手机系统上是指的它实际运行过程中是在用户的手机上吗？（比如用户手机就是一个server）还是说apple有其他外的服务器来支持apns？<ul>
<li>用户的手机是一个 client 不是一个 server，用户的手机不需要给其他人提供服务，他只问被人要服务。Push Notification System 是 Apple/ Google 单独搭建的一套服务器系统，专门用来提供 push 服务。</li>
</ul>
</li>
<li>是不是现在也有些浏览器提供push notification？比如Chrome？<ul>
<li>浏览器的push notification本质上就是一个弹出的对话框，本质上还是网页自己基于websocket一类的技术实现的，跟GCM/APNS原理不一样。</li>
</ul>
</li>
<li>不太理解为什么server不直接和B通讯呢？通过GCM作为中介的好处是？<ul>
<li>APNS/GCM都是专门用于移动端的消息推送的，为消息推送提供了一个与操作系统深度整合的、高度优化的框架，如果不用这个的话，就得自己重新造一套这样的消息推送框架，费时费力，而且标准不一。而且假设你有50个app, 如果每个app都需要链接各自的push服务器的话，会给手机带来很大的负担。具体的讨论可以看这里：<a href="https://stackoverflow.com/questions/31645010/why-it-is-preferred-to-use-gcm-for-push-notifications" target="_blank" rel="noopener">https://stackoverflow.com/questions/31645010/why-it-is-preferred-to-use-gcm-for-push-notifications</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>沒有提供給所有的browser推送系統的。該怎辦呢？</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>解決的辦法就是自己搭push的服務，不要依賴第三方的push 通知服務。實時性會更高。</p>
<p>★ HTTP 只支持客戶端向服務器獲取數據，因為Server不知道客戶在哪； client to server 是有ip、域名的</p>
<p>Socket是讓服務器可以主動向客戶端推數據。</p>
<p>Socket, 跟 http一樣都是tcp/ip，本來就都可以雙向通信。http不能保持連接，socket可以。</p>
<p>要是push server掛的話，就回到PULL，10秒拉一次，反正client是知道連接斷開了的</p>
<blockquote>
<ul>
<li>为什么不用 long polling呢<ul>
<li>当clients很多的时候，long polling会让server返回大量的空结果（没有新信息的时候），这样会给server带来很大的负担，比较浪费资源。</li>
</ul>
</li>
<li>Push server needs to keep too many connections, would not this be a problem?<ul>
<li>yes, so push server always push messsges async</li>
</ul>
</li>
<li>push server是不是和message queue/kafka差不多？<ul>
<li>不是的，push server 和 message queue 是完全不同的东西。push server 里就是通过 socket 连着用户，有消息就推一下而已。而 message queue 是把需要执行的任务信息存储在 queue 里，等着执行任务的进程来逐个领取的一个中间缓存机构。<strong>本质上来说 push server 是 stateless 的，是不存数据的。message queue 是 stateful 的，是存数据的</strong>。<em>就跟 web server 和 database 之间的本质区别一样。</em></li>
</ul>
</li>
<li>如果A或者B离线呢，消息存在哪？<ul>
<li>消息存在 Message Service 里（数据库里），socket 只是“提醒” 的作用，并不是说消息只从 socket 走。你可以认为 socket 里走的数据是“嘿你有消息了，去服务器拿一下”，然后用户去服务器拿到最新消息。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Group-Chat"><a href="#Group-Chat" class="headerlink" title="Group Chat"></a>Group Chat</h3><p>大群裡，可能只有很少人在線，就是只有很少人需要被即時推送。</p>
<p>這樣也不需要優化得那麼實時。</p>
<blockquote>
<ul>
<li>相較於使用channel 篩選在線用戶的方式, 老師後面有說可以建一個 online status 的 table, 那我是不是可以直接從online status裡面檢查群聊還有在線的, 直接send message給在線的就好. 感覺好像比用channel還要subscribe的方式簡單?<ul>
<li>不行。online status table 里在线不代表这个人已经连接上了 push socket（虽然大概率是连着的），但是这种反向调用关系是不好的架构设计，类似写代码的时候底层函数调用了上层函数，会导致系统之间的依赖关系出现循环依赖。</li>
</ul>
</li>
<li>一般来说是多少人以上的群采用channel service呢？还是说哪怕两个人私聊也算一个两个人订阅的channel?<ul>
<li>一般可能10+ 人才会走 public channel。如果是私聊，走的是 private channel，也就是说，比如你的 user_id 是 10，那么所有和你私聊的信息，都走到 “#user_10” 这个channel里去（这个channel名字的格式你自己可以随意定义）。你一上线也会自己订阅这个channel。这个channel 只属于你自己，不和别人共享。</li>
</ul>
</li>
<li>这里的channel service可以换成message queue么？生产者也是只用发一次消息，然后订阅的消费者去取这些消息？这里channel service和massage queue有什么区别？谢谢<ul>
<li>不可以。channel service 是 fanout，是广播。一条消息会被多个 subscriber 拿到。message queue 不是广播，一条任务消息必须保证只被一个 task worker 拿到。</li>
</ul>
</li>
<li>channel service 可以用kafka么？<ul>
<li>这样用不太对。kafka 是消息队列，channel 是一个 key-value 的存储 + 信息 fanout。</li>
</ul>
</li>
<li>所以用户下线以后就自动取消订阅channel service吗？<ul>
<li>用户下线的时候push server会知道用户下线了，然后push server会把这件事通知给channel service。</li>
</ul>
</li>
<li>如果用户不在线的话，历史消息怎么办呢？是储存在channel service里面吗？<ul>
<li>用户不在线的时候channel service就不会给相应用户推送，也不会保存这条消息，channel service只是为了给在线用户实时推送消息，至于历史消息是用户上上线的时候自己去Message Service里面pull的。</li>
</ul>
</li>
<li>以前课提到的明星效应问题可以考虑用pull， 我们的大group 也有点类似明星效应问题，但是不用pull，是不是因为消息系统有实时性的要求？<ul>
<li>大 Group 是 500 个人的 Group。这个和明星的 50m 的粉丝不是一个量级的。这里用 push 的原因最主要还是用户行为，人们阅读聊天信息通常都是被动的。而人们阅读 SNS 的信息通常都是主动的。</li>
</ul>
</li>
<li>那么实际实现的时候，是针对大群才用 channel service？<ul>
<li>不是。都会用到 channel，只是走 Public channel 还是 private channel 的区别。比如私信，或者小群，可以走每个人 private channel，这些 private channel 只有用户自己订阅，其他人不会订阅。而大群就放在 Public channel，里面会有好多人。</li>
</ul>
</li>
<li>所以对于未上线用户，channel service最终还是会把历史消息存到数据库里，等待用户上线pull？<ul>
<li>并不是 channel service 把历史消息存到数据库里。消息最开始就先经过 Message Service，先被存储在了数据库里，然后才通过 channel service 去提醒用户查看。通过 channel 和 push server / socket 走的信息都是提醒信息，你可以认为里面的内容是“嘿，你有新消息了，快去服务器取”，而不要把 channel service 当作了消息本身最开始被传递到的地方。</li>
</ul>
</li>
<li>所以channel service 是fan out的，然后push server是点对点的给client推送的？<ul>
<li>没错， channel server 是负责 fanout 的，push server 是点对点完成具体推送的。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Channel-Service-QA"><a href="#Channel-Service-QA" class="headerlink" title="Channel Service QA"></a>Channel Service QA</h3><blockquote>
<ul>
<li>channel和Thread为什麽不是一一对应的关系？<ul>
<li>channel是架构上的逻辑，thread是具体到代码实现层的，不是一个层面的概念</li>
</ul>
</li>
<li>Channel service要自己写吗？还是说有什么线程的软件？<ul>
<li>自己寫</li>
</ul>
</li>
<li>系统怎么知道哪些消息已经被poll过，或者是从channel发送的？会不会有重复<ul>
<li>client可以通过告诉server自己本地已有的最新一条信息是哪条，或者告诉server自己随后一次同步的时间戳，然后server就直接返回该时间戳之后的消息。另外每个message都是有id的，所以即使client收到了两条一样的消息client也能识别出来是同一条消息。</li>
</ul>
</li>
<li>channel name也应该存在其他table里面吧？要不然web service收到一个讯息时怎么知道该送往哪个channel呢？是该加入在user thread table吗？<ul>
<li>不需要有一个单独的 table。web service 收到 channel 信息的时候直接转给 channel service 去 push 即可。很多时候 web service 不是直接从 client 那里得到 channel name。而是直接构造。比如 thread 的channel 可以就叫 <code>#thread1</code> <code>#thread2</code> 这种。有一个规则可以构造即可。</li>
</ul>
</li>
<li>为什么不对每个thread做channel, personal channel有什么message?对personal channel推送的时候前端怎么知道属于哪个thread?这是一种针对人数少的群的优化么？<ul>
<li>如果对每个 thread 都做一个channel，是可以的。只是不够高效，因为很多用户的 threads 里很多是1对1的聊天，这种做到 channel 里不划算。所以通过一个统一的 personal channel，来推送某个用户1对1或者人数比较少的thread 里的信息提醒。personal channel 推送的时候，可以根据 channel 的名字来解析出属于哪个用户，比如 personal channel 的名字格式可以定义为：”personal#1234” 表示是 1234 这个用户的 channel。</li>
</ul>
</li>
<li>所以channel是messaging service 创建的，对用户透明？<ul>
<li>channel是由单独的channel service创建的，messaging service将推送群聊消息的任务委托给channel service，然后channel service再自己去把消息push给群里的在线用户。这整个过程对用户是透明的，用户眼中只有”群”的概念，没有channel的概念。</li>
</ul>
</li>
<li>不太明白#personal::user_1的用法。即使是1对1私聊user_1也可以跟user_2,user_3同时进行，这时难道#personal::user_1里有user_2和user_3吗？消息串了怎么办？而且user_2,user_3不也有自己的personal channel吗？<ul>
<li>#personal:user1是user1的私人频道，只有user1一个人订阅，所有发给user1的私信都会在这里推送。比如user2给user1发消息的时候，messaging service收到消息之后会让channel service向#personal:user1推送一条消息｛thread: user1#user2, from: user2, content: xxxx}，此时user1收到消息之后，识别出该消息是来自user2的私信，因此显示在跟user2的聊天框里，消息是不会串的。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>老师可不可以简单解释一下“对方正在打字”这个功能是怎么实现的？<ul>
<li>问得好！这个叫做 TypyIndicator，有的公司专门拿来做面试题。实现方式其实很简单，首先 Storage 这个方面其实这个信息是不需要存储的，即便要存储（比如为了做数据分析）也就是存储最后一次 type 的时间就好了。 client A 检测到用户正在输入以后，发一个轻量级的消息给 server， server 通过 push service 发正在输入的信息给 client B，然后 client B 就显示用户正在输入。约定一个检测时间，比如当用户在输入框里输入的时候，大概每隔1-3s 就发送一次这种信息 push（具体取几秒钟看产品经理怎么拍脑袋了）。</li>
</ul>
</li>
</ul>
</blockquote>
<p>活躍時就poll先休息，所以會用推的比較快</p>
<h2 id="多機登陸"><a href="#多機登陸" class="headerlink" title="多機登陸"></a>多機登陸</h2><p>session中紀錄用戶info</p>
<h2 id="On-line-status"><a href="#On-line-status" class="headerlink" title="On-line status"></a>On-line status</h2><p>可用push的socket去看是否在線嗎？</p>
<p>實時性要求不高，可以用PULL.　</p>
<blockquote>
<ul>
<li>如果server发现用户在一定时间内没有pull请求，是不是可以标记为offline，然后对他的所有好友也告知此人offline？<ul>
<li>可以，不过一般不是server主动去push通知其好友用户A已经offline，而是好友在自己发出heartbeat pull或者主动请求好友在线信息的时候服务器才告诉该好友用户A已经下线。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><img src="/Users/joe/Library/Application Support/typora-user-images/image-20200410203715392.png" alt="image-20200410203715392" style="zoom:50%;" />



<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200410210741607.png" alt="image-20200410210741607" style="zoom:50%;" />



<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdoz6w1gbxj30i20ye0we.jpg" alt="image-20200410210804359" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200411222125219.png" alt="image-20200411222125219" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200411222144074.png" alt="image-20200411222144074" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq6ydxcquj30ii0mk40f.jpg" alt="image-20200411222215512" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200411222247062.png" alt="image-20200411222247062" style="zoom:50%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200411231451591.png" alt="image-20200411231451591" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq8ivyb8cj30n20w010o.jpg" alt="image-20200411231633812" style="zoom:50%;" />

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdq8keeocxj30m20oq794.jpg" alt="image-20200411231800981" style="zoom:50%;" /></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/10/Web/Django/2019-04-10-Django%20note/">Web/Django/2019-04-10-Django note</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Django/">Django</a></span><div class="content"></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/45/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><span class="page-number current">46</span><a class="page-number" href="/page/47/">47</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" href="/page/47/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>